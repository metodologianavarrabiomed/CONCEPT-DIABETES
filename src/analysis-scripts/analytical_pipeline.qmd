---
title: "CONCEPT DIABETES: Analytical pipeline"
author: Ignacio Oscoz Villanueva
editor: visual
crossref:
  lof-title: "List of Figures"
  fig-labels: arabic    # (default is arabic)
  tbl-labels: arabic    # (default is arabic)
  subref-labels: alpha a # (default is alpha a)
#date: 
# bibliography: 
format: 
  html:
    embed-resources: true
    toc: true
    toc-depth: 4
    highlight-style: pygments
    code-fold: true
    html-math-method: katex
execute: 
  warning: false
  cache: false
---

```{css, echo = FALSE}
.justify {
  text-align: justify !important
}
```

## Introduction

### CONCEPT-DIABETES

CONCEPT-DIABETES is part of CONCEPT, a coordinated research project initiative under the umbrella of REDISSEC, the Spanish Research Network on Health Services Research and Chronic Conditions\] \[www.redissec.com\], that aims at analyzing chronic care effectiveness and efficiency in a number of cohorts built on real world data (RWD). In the specific case of CONCEPT-DIABETES, the focus will be on assessing the effectiveness of a set of clinical practice actions and quality improvement strategies at different levels (patient-level, health-care provider level and health system level) on the management and health results of patients with type 2 diabetes (T2D) using process mining methodology.

It is a population-based retrospective observational study centered on all T2D patients diagnosed in four Regional Health Services within the Spanish National Health Service, that includes information from all their contacts with the health services using the electronic medical record systems including Primary Care data, Specialist Care data, Hospitalizations, Urgent Care data, Pharmacy Claims, and also other registers such as the mortality and the population register. We will assess to what extent recommended interventions from evidence-based guidelines are implemented in real life and which are their effects on health outcomes. Process mining methods will be used to analyze the data, and comparison with standard methods will be also conducted.

### Cohort

The cohort is defined as patients with type 2 diabetes:

-   Inclusion criteria: Patients that, at 2017-01-01 or during the follow-up from 2017-01-01 to 2022-12-31, had active health card (active TIA - tarjeta sanitaria activa) and one of the inclusion codes given in the 'inclusion code list ('T90' if CIAP-2, '250' if 'CIE-9CM' or 'E11' if CIE-10-ES).

-   Exclusion criteria: Patients that had none of the exclusion codes given in the exclusion codes list ('T89' if CIAP-2, '250.01' if CIE-9CM, '250.03' if CIE-9CM, '250.11' if CIE-9CM, '250.13' if CIE-9CM, '250.21' if CIE-9CM, '250.23' if CIE-9CM, '250.31' if CIE-9CM, '250.33' if CIE-9CM, '250.41' if CIE-9CM, '250.43' if CIE-9CM, '250.51' if CIE-9CM, '250.53' if CIE-9CM, '250.61' if CIE-9CM, '250.63' if CIE-9CM, '250.71' if CIE-9CM, '250.73' if CIE-9CM, '250.81' if CIE-9CM, '250.83' if CIE-9CM, '250.91' if CIE-9CM, '250.93' if CIE-9CM or 'E10' if CIE-10-ES) during their follow-up or patients with no contact with the health system from 2017-01-01 to 2022-12-31.

-   Study period: 2017-01-01 until 2022-12-31.

### Treatment guidelines

One of the main intermediate outcome indicators to which clinical guidelines pay special attention is a good glycaemic control, since its absence is clearly related to micro and macrovascular complications. In clinical practice, suboptimal glycaemic control can be mainly attributed to two main reasons: the patients' non-adherence to prescribed treatment; and the healthcare providers' clinical or therapeutic guidelines' non-adherence.

Treatment decisions are based on glycated hemoglobin measurements. In this context the redGDPS foundation provides DM2 treatment algorithm, a diagram that aims to help professionals to quickly and easily choose the most appropriate treatment for people with diabetes.

<object data="./Algoritmo_DM2_ENG_2023.pdf" type="application/pdf" width="800px" height="400px">

<embed src="./Algoritmo_DM2_ENG_2023.pdf">

<p>This browser does.</p>

</embed>

</object>

### Process indicators

Another measures to which different studies pay special attention are process indicators. First, process indicators are essential for assessing the three dimensions of healthcare quality: effectiveness, safety, and patient-centeredness. They are measured relatively easily and often do not require risk-adjustment, making their interpretation straightforward. Poor performance on process indicators can be directly attributed to the actions of healthcare providers, providing a clear indication for improvement, such as better adherence to clinical guidelines. Moreover, process indicators allow for the identification of areas for quality improvement, which is crucial in the complex healthcare environment. These indicators cover a wide range of health factors and help focus resources and efforts to improve the health and well-being of the population. Therefore, the attention given to health process indicators is justified by their crucial role in evaluating and improving healthcare quality and population health.

## Running code

The python libraries used are:

```{python}
#| label: Load python packages (to show)
#| eval: FALSE
#| echo: TRUE
#| warning: FALSE
#| output: FALSE
import sys
import pm4py, subprocess
import pandas as pd
import numpy as np
import itertools
import matplotlib.pyplot as plt
import textdistance
import gensim.corpora as corpora
from tqdm import trange, tqdm
from scipy.spatial.distance import squareform
from scipy.cluster.hierarchy import fcluster, linkage, dendrogram
from sklearn.cluster import AgglomerativeClustering 
from sklearn.feature_extraction.text import TfidfVectorizer
from yellowbrick.cluster import KElbowVisualizer
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.visualization.decisiontree import visualizer as tree_visualizer
from pm4py.algo.decision_mining import algorithm as decision_mining
from pm4py.visualization.petri_net import visualizer
from gensim.models import LdaModel
from datetime import  datetime, timedelta
from dateutil.relativedelta import relativedelta
import duckdb
import re
import logging
```

```{python}
#| label: Load python packages
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
import sys
import pm4py, subprocess
import pandas as pd
import numpy as np
import itertools
import matplotlib.pyplot as plt
import textdistance
import gensim.corpora as corpora
from tqdm import trange, tqdm
from scipy.spatial.distance import squareform
from scipy.cluster.hierarchy import fcluster, linkage, dendrogram
from sklearn.cluster import AgglomerativeClustering 
from sklearn.feature_extraction.text import TfidfVectorizer
from yellowbrick.cluster import KElbowVisualizer
from pm4py.objects.petri_net.obj import PetriNet, Marking
from pm4py.visualization.decisiontree import visualizer as tree_visualizer
from pm4py.algo.decision_mining import algorithm as decision_mining
from pm4py.visualization.petri_net import visualizer
from gensim.models import LdaModel
from datetime import  datetime, timedelta
from dateutil.relativedelta import relativedelta
import duckdb
import re
import logging
import seaborn as sns
from rapidfuzz.distance import Levenshtein
```

The R libraries used are:

```{r}
#| label: Load r libraries
#| warning: FALSE

library(tidyverse)
library(lubridate)
library(jsonlite)
library(ggplot2)
library(bupaR)
library(processmapR)
library(dplyr)
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)
library(here)
library(survival)
library(lcmm)
library(coxme)
library(muhaz)
library(ggfortify)
library(bayestestR)
library(purrr)
library(duckdb)
library(logger)
library(finalfit)
library(flextable)
library(knitr)

```
### Data preprocessing

First of all, it is important to prepare correctly the data for the analysis. The next function creates some sql views that are going to be useful later:
```{python, warning: FALSE}
#| label: data preprocess
#| warning: FALSE
def general_preprocess(con):
    '''
    Generating  views
    Args:
        con : db connector variable
    '''
    con.sql("DROP VIEW IF EXISTS cmbd_incidents_view;")
    con.sql("DROP VIEW IF EXISTS comorb_incidents_view;")    
    con.sql("DROP VIEW IF EXISTS ss_use_incidents_view;")
    con.sql("DROP VIEW IF EXISTS param_incidents_view_;")
    con.sql("DROP VIEW IF EXISTS param_incidents_view;")
    con.sql("DROP VIEW IF EXISTS param_cat_incidents_view;")    
    con.sql("DROP VIEW IF EXISTS patient_incidents_view;")
    con.sql("DROP VIEW IF EXISTS treat_incidents_view;")
    con.sql("DROP VIEW IF EXISTS exams_incidents_view;")


    con.sql("CREATE VIEW cmbd_incidents_view AS SELECT * FROM main.cmbd \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01')")
    con.sql("CREATE VIEW ss_use_incidents_view AS SELECT * FROM main.ss_use \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01')")
    con.sql("CREATE VIEW comorb_incidents_view AS SELECT * FROM main.comorb \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01')")
    con.sql("CREATE VIEW param_incidents_view_ AS SELECT DISTINCT * FROM main.param \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01') \
                AND (param_value!=0 OR param_name!='bmi')")
    con.sql("CREATE VIEW param_incidents_view AS \
            SELECT DISTINCT patient_id,param_name,MAX(param_value) AS param_value,param_date\
        FROM param_incidents_view_ GROUP BY patient_id,param_name,param_date")
    con.sql("CREATE VIEW param_cat_incidents_view AS SELECT DISTINCT * FROM main.param_cat \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01')")
    con.sql("CREATE VIEW patient_incidents_view AS SELECT *,\
            FLOOR(DATEDIFF('day',month_nac,DATE '2017-01-01') / 365.25) \
                AS 'age', \
            FLOOR(DATEDIFF('day',month_nac, dx_date) / 365.25) \
                AS 'age_dx', \
            DATE_ADD(month_nac, INTERVAL 75 YEAR) AS 'turn_to_75', \
            DATE_ADD(month_nac, INTERVAL 65 YEAR) AS 'turn_to_65' \
                FROM main.patient WHERE patient_id IN (SELECT patient_id \
                        FROM main.patient WHERE dx_date >='2017-01-01')")
    con.sql("CREATE VIEW treat_incidents_view AS SELECT * FROM main.treat \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01')")
    con.sql("CREATE VIEW exams_incidents_view AS SELECT * FROM main.exams \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01')")
                
    con.sql("DROP VIEW IF EXISTS param_incidents_view_age_date;")    
    con.sql("CREATE VIEW param_incidents_view_age_date AS SELECT param_incidents_view.patient_id, \
            param_name, param_value, param_date, turn_to_65, turn_to_75 FROM \
                param_incidents_view LEFT JOIN patient_incidents_view ON \
         param_incidents_view.patient_id = patient_incidents_view.patient_id")

    con.sql("DROP VIEW IF EXISTS cmbd_incidents_postdx_view")
    con.sql("CREATE VIEW cmbd_incidents_postdx_view AS \
            SELECT * FROM cmbd_incidents_view \
                WHERE admission_date > (SELECT dx_date \
                                        FROM patient_incidents_view \
    WHERE patient_incidents_view.patient_id = cmbd_incidents_view.patient_id)")
                    
    con.sql("DROP VIEW IF EXISTS cmbd_incidents_postdx_first_view")
    con.sql("CREATE VIEW cmbd_incidents_postdx_first_view AS \
            SELECT patient_id, admission_date, diagnosis1_code FROM (SELECT *,\
                      ROW_NUMBER() OVER(PARTITION BY patient_id \
                                        ORDER BY admission_date) AS rn \
                          FROM cmbd_incidents_postdx_view) t WHERE rn = 1;")
                
    con.sql("DROP VIEW IF EXISTS param_incidents_predx_view;")
    con.sql("CREATE VIEW param_incidents_predx_view AS SELECT * FROM (\
            SELECT * FROM (SELECT patient_id, param_name, param_value, param_date \
                            FROM param_incidents_view) sub \
                WHERE param_date <= (SELECT dx_date FROM patient_incidents_view \
                    WHERE patient_incidents_view.patient_id = sub.patient_id));")
        
    con.sql("DROP VIEW IF EXISTS param_incidents_predx_last_view;")        
    con.sql("CREATE VIEW param_incidents_predx_last_view AS \
            SELECT patient_id, param_name, param_date, param_value \
                FROM (SELECT patient_id, param_name, param_date, param_value,\
                      ROW_NUMBER() OVER(PARTITION BY patient_id, param_name \
                                        ORDER BY param_date DESC) AS rn \
                          FROM param_incidents_predx_view \
                          WHERE param_value!=9999) t WHERE rn = 1;")
                    
    con.sql("DROP VIEW IF EXISTS param_cat_incidents_predx_view;")                    
    con.sql("CREATE VIEW param_cat_incidents_predx_view AS SELECT * FROM (\
            SELECT * FROM (SELECT patient_id, param_cat_name, param_cat_value, param_cat_date \
                            FROM param_cat_incidents_view) sub \
                WHERE param_cat_date <= (SELECT dx_date FROM patient_incidents_view \
                    WHERE patient_incidents_view.patient_id = sub.patient_id));")
    con.sql("DROP VIEW IF EXISTS param_cat_incidents_predx_last_view;")
    con.sql("CREATE VIEW param_cat_incidents_predx_last_view AS \
            SELECT patient_id, param_cat_name, param_cat_date, param_cat_value \
                FROM (SELECT patient_id, param_cat_name, param_cat_date, param_cat_value,\
                      ROW_NUMBER() OVER(PARTITION BY patient_id, param_cat_name \
                                        ORDER BY param_cat_date DESC) AS rn \
                          FROM param_cat_incidents_predx_view) t WHERE rn = 1;") 
                    
    con.sql("DROP VIEW IF EXISTS param_prevalents_pre_view;")
    con.sql("CREATE VIEW param_prevalents_pre_view AS \
            SELECT DISTINCT patient_id, param_name, param_value, param_date FROM main.param \
             WHERE param_date < '2017-01-01' AND patient_id IN (\
                SELECT patient_id FROM main.patient WHERE dx_date < '2017-01-01')")
    con.sql("DROP VIEW IF EXISTS param_prevalents_pre_last_view;")
    con.sql("CREATE VIEW param_prevalents_pre_last_view AS \
            SELECT patient_id, param_name, param_date, param_value \
                FROM (SELECT patient_id, param_name, param_date, param_value,\
                      ROW_NUMBER() OVER(PARTITION BY patient_id, param_name \
                                        ORDER BY param_date DESC) AS rn \
                          FROM param_prevalents_pre_view \
                              WHERE param_value!=9999) t WHERE rn = 1;")
                    
    con.sql("DROP VIEW IF EXISTS param_cat_prevalents_pre_view;")
    con.sql("CREATE VIEW param_cat_prevalents_pre_view AS \
            SELECT DISTINCT * FROM main.param_cat \
             WHERE param_cat_date < '2017-01-01' AND patient_id IN (\
                SELECT patient_id FROM main.patient WHERE dx_date < '2017-01-01')")
    con.sql("DROP VIEW IF EXISTS param_cat_prevalents_pre_last_view;")
    con.sql("CREATE VIEW param_cat_prevalents_pre_last_view AS \
            SELECT patient_id, param_cat_name, param_cat_date, param_cat_value \
                FROM (SELECT patient_id, param_cat_name, param_cat_date, param_cat_value,\
                      ROW_NUMBER() OVER(PARTITION BY patient_id, param_cat_name \
                                        ORDER BY param_cat_date DESC) AS rn \
                          FROM param_cat_prevalents_pre_view) t WHERE rn = 1;") 

```

### Treatments' event log creation

For using process mining an event log is needed. The sort of functions below take data model's treatment and parameter tables to create an event log of glycated hemoglobin measures and treatment of patients. Glycated hemoglobin measurement events are divided into two different states, those that have a value smaller than "L" and the others. L's value depends on patient's diabetes duration, age and comorbilities and complications. Therefore with the help of expert clinicians we decided that L would take the following values:

-   L=7 if age<75 and no cardiovascular disease, heart failure, chronic kidney disease or fragility.
-   L=8 if age<65 and any cardiovascular disease, heart failure, chronic kidney disease or fragility.
-   L=8.5 if else.

As they are measures these events do not have any duration. In the case of treatments on the other hand a duration period exists. For treatments, events definition is based on drugs prescriptions if exists or dispensing dates and a fixed period time if else. Functions below make event logs with the previous considerations. Treatment analysis of this document is thought to do by the predominant clinical condition of patients according to DM2 treatment algorithm. In other words, patients are grouped by their predominant clinical condition and the analysis is realized independently to each group.


```{python, warning: FALSE}
#| label: treatments' event log creation
#| warning: FALSE
logging.basicConfig(level=logging.INFO)
def separate_patients_by_condition(con):
    '''
    Filtering data by predominant clinical condition according to redGDPS
    Args:
        con : db connector variable
    Return:
        presc_data_p (float): percentage of not null data in prescription dates
        
    https://www.sciencedirect.com/science/article/pii/S1751991821000176?via%3Dihub#tbl0015
    https://www.sanidad.gob.es/estadEstudios/estadisticas/estadisticas/estMinisterio/SIAP/map_cie9mc_cie10_ciap2.htm
    
     obesity (BMI≥30 kg/m2), age older than 75, established CVD (defined as
     myocardial infarction, ischemic heart disease, cerebrovascular disease,
     or peripheral arterial disease), CKD (defined as eGFR < 60 ml/min/
     1.73 m2 and/or UACR ≥ 30 mg/g) and HF. 
    '''
    cvd_code_list = ['K76','K75','K76','K91','K92']
    hf = 'K77'
    ckd = 'U99.01'
    ob = "T82"

    to_list = lambda l: "('"+"','".join(l)+"')"     
                    
                    
    presc_data_p = con.sql(f" SELECT (COUNT(prescription_date_ini)) / COUNT(*) \
                           AS p FROM treat_incidents_view").fetchall()[0][0]
    cie9_df = pd.read_csv('./CIE9.csv').rename(columns={'CIE9':'CIE',
                                                        'BDCAP':'CIAP'})
    cie9_df['comorb_codif'] = 'ICD9'
    cie10_df = pd.read_csv('./CIE10.csv').rename(columns={'CIE10':'CIE',
                                                          'BDCAP':'CIAP'})
    cie10_df['comorb_codif'] = 'ICD10'
    cie2ciap = pd.concat([cie9_df[['comorb_codif','CIE','CIAP']],
                          cie10_df[['comorb_codif','CIE','CIAP']]])
    
    con.sql("DROP VIEW IF EXISTS comorb_incidents_ciap_view;")    
    con.sql("DROP VIEW IF EXISTS comorb_incidents_active_view;")    
    con.sql("CREATE VIEW comorb_incidents_ciap_view AS \
            SELECT * FROM comorb_incidents_view \
                LEFT JOIN cie2ciap \
                    ON comorb_incidents_view.comorb_codif = cie2ciap.comorb_codif \
                        AND comorb_incidents_view.comorb_code = cie2ciap.CIAP")
    con.sql("CREATE VIEW comorb_incidents_active_view AS SELECT *, \
            CASE WHEN comorb_codif = 'CIAP2' THEN comorb_code ELSE CIAP END AS CIAP2 \
                FROM comorb_incidents_ciap_view WHERE comorb_date_end IS NULL;")

    # Which is the predominal clinical condition at baseline?
    f_list = set()
    ob_list = set(con.sql(f"SELECT DISTINCT patient_id \
                          FROM comorb_incidents_active_view WHERE CIAP2 = '{ob}'"
                          ).df()['patient_id'])        
    ckd_list = set(con.sql(f"SELECT DISTINCT patient_id \
                           FROM comorb_incidents_active_view WHERE CIAP2 = '{ckd}'"
                           ).df()['patient_id'])        
    hf_list = set(con.sql(f"SELECT DISTINCT patient_id \
                          FROM comorb_incidents_active_view WHERE CIAP2 = '{hf}'"
                          ).df()['patient_id'])        
    cvd_list = set(con.sql(f"SELECT DISTINCT patient_id \
                           FROM comorb_incidents_active_view \
                               WHERE CIAP2 IN {to_list(cvd_code_list)}"
                               ).df()['patient_id'])        

    # Which is the predominal clinical condition at dx_date?
    # ENFERMEDADES ISQUÉMICAS CARDIACAS (I20-I25)
    # ENFERMEDADES CEREBROVASCULARES (I60-I69)
    # ATEROESCLEROSIS (ENFERMEDADES VASCULARES PERIFÉRICAS) (I70)
    # OTRAS ENFERMEDADES VASCULARES PERIFÉRICAS (I73)
    # EMBOLIA Y TROMBOSIS ARTERIAL (ENFERMEDADES VASCULARES PERIFÉRICAS) (I74)
    to_cvd_change_prelist = ['I2%i' %i for i in range(6)]+[
                             'I6%i' %i for i in [1,3,4,5,6,7,8,9]]+[
                                'I7%i' %i for i in [0,3,4]]
    to_cvd_change_list = []
    for code in to_cvd_change_prelist:
     for c in cie10_df['CIE']:
      if code in c and c not in ['I51.4','I60','I62','I67.1','I68.2','I67.5']:
                to_cvd_change_list.append(c)
    # INSUFICIENCIA CARDÍACA (I50)
    # ENFERMEDAD CARDÍACA Y RENAL CRÓNICA HIPERTENSIVA (I13)
    to_hf_change_list = ['I09.81', 'I11.0', 'I13.0', 'I13.2', 'I50', 'I50.0',
                         'I50.1', 'I50.9']
    # ENFERMEDAD RENAL CRÓNICA (N18)
    # ENFERMEDAD RENAL CRÓNICA HIPERTENSIVA (I12)
    to_ckd_change_list = ['N18','N18.1','N18.2','N18.3','N18.30','N18.31',
                          'N18.32','N18.4','N18.5','N18.6','N18.9','I12',
                          'I12.0','I12.9','filtglom']
    to_f_change_list = ['f_date']
    to_ob_change_list = ['bmi>=30','E66.01','E66.09','E66.1','E66.2',
                         'E66.8','E66.9']
    # SOBREPESO Y OBESIDAD (E66)
    from_cvd_change_list = ['death']
    from_hf_change_list = from_cvd_change_list+to_cvd_change_list
    from_ckd_change_list = from_hf_change_list+to_hf_change_list
    from_f_change_list = from_ckd_change_list+to_ckd_change_list
    from_ob_change_list = from_f_change_list+to_f_change_list+['bmi<30']
    from_else_change_list = from_ob_change_list[:-1]+to_ob_change_list
    
    relevance_order = pd.DataFrame()
    relevance_order['code'] = from_ob_change_list+to_ob_change_list+['end']
    relevance_order['order'] = range(len(relevance_order))

    
       
    # https://ukkidney.org/health-professionals/information-resources/uk-eckd-guide/ckd-stages
    # Include obesity and kcd detection by parameters values                             
    param_filt = con.sql("SELECT * FROM param_incidents_view \
                         WHERE param_name = 'filtglom' AND param_value<60;"
                         ).df().sort_values(['patient_id','param_date'])
    param_filt['time_diff'] = param_filt.groupby(
        'patient_id')['param_date'].diff()
    cmbd_filt = param_filt[param_filt['time_diff'] < pd.Timedelta(days=90)
                           ].drop_duplicates(subset='patient_id',keep='first')[
                               ['patient_id','param_date','param_name']
                               ].rename(columns={
                                   'param_name':'code',
                                   'param_date':'admission_date'})
    con.sql("DROP VIEW IF EXISTS cmbd_incidents_long_view;")
    con.sql("CREATE VIEW cmbd_incidents_long_view AS SELECT *,\
            COALESCE(t.order, 404) AS relevance FROM\
            (SELECT patient_id, admission_date, diagnosis1_code AS code \
                FROM cmbd_incidents_view WHERE diagnosis1_code IS NOT NULL \
            UNION ALL SELECT patient_id, admission_date, diagnosis2_code AS code \
                FROM cmbd_incidents_view WHERE diagnosis2_code IS NOT NULL \
            UNION ALL SELECT patient_id, admission_date, diagnosis3_code AS code \
                FROM cmbd_incidents_view WHERE diagnosis3_code IS NOT NULL \
            UNION ALL SELECT patient_id, admission_date, code FROM cmbd_filt \
            UNION ALL SELECT patient_id, turn_to_75 AS admission_date, 'f_date' \
                AS code FROM patient_incidents_view WHERE turn_to_75<'2023-01-01'\
            UNION ALL SELECT patient_id, death_date AS admission_date, 'death' \
                AS code FROM patient_incidents_view WHERE death_date IS NOT NULL\
            UNION ALL SELECT patient_id, DATE '2023-01-01' AS admission_date, 'end' \
                AS code FROM patient_incidents_view\
            UNION ALL SELECT patient_id,param_date AS admission_date, \
        CASE WHEN param_value < 30 THEN 'bmi<30' ELSE 'bmi>=30' END AS code \
            FROM param_incidents_predx_last_view WHERE param_name = 'bmi' \
            UNION ALL SELECT patient_id, param_date AS admission_date, \
        CASE WHEN param_value < 30 THEN 'bmi<30' ELSE 'bmi>=30' END AS code \
            FROM param_incidents_view sub WHERE param_name = 'bmi' \
                AND  param_date > (SELECT dx_date FROM patient_incidents_view \
                                   WHERE patient_incidents_view.patient_id = sub.patient_id)) v \
                LEFT JOIN relevance_order t ON v.code=t.code;")
    
    f_list.update(set(con.sql("SELECT DISTINCT patient_id \
                              FROM patient_incidents_view WHERE turn_to_75<=dx_date"
                              ).df()['patient_id']))
    con.sql("DROP VIEW IF EXISTS ob_events;")
    con.sql(f"CREATE VIEW ob_events AS SELECT * \
            FROM cmbd_incidents_long_view sub \
                WHERE code IN {to_list(to_ob_change_list)} \
                    AND admission_date <= (SELECT dx_date \
                    FROM patient_incidents_view \
                        WHERE patient_incidents_view.patient_id = sub.patient_id);"
                            )
    ob_list.update(set(con.sql("SELECT DISTINCT patient_id \
                           FROM ob_events").df()['patient_id']))
        
    ob_list = ob_list - set(con.sql(f"SELECT DISTINCT patient_id \
                           FROM cmbd_incidents_long_view sub \
                               WHERE code='bmi<30' \
                                   AND admission_date <= (SELECT dx_date \
                        FROM patient_incidents_view \
                            WHERE patient_incidents_view.patient_id = sub.patient_id) \
                                   AND admission_date > (SELECT MAX(admission_date)\
                        FROM ob_events \
                            WHERE ob_events.patient_id  = sub.patient_id);"
                                   ).df()['patient_id'])
    ckd_list.update(set(con.sql(f"SELECT DISTINCT patient_id \
                           FROM cmbd_incidents_long_view sub \
                               WHERE code IN {to_list(to_ckd_change_list)} \
                                   AND admission_date <= (SELECT dx_date \
                        FROM patient_incidents_view \
                            WHERE patient_incidents_view.patient_id = sub.patient_id);"
                            ).df()['patient_id']))        
    hf_list.update(set(con.sql(f"SELECT DISTINCT patient_id \
                           FROM cmbd_incidents_long_view sub \
                               WHERE code IN {to_list(to_hf_change_list)} \
                                   AND admission_date <= (SELECT dx_date \
                        FROM patient_incidents_view \
                            WHERE patient_incidents_view.patient_id = sub.patient_id);"
                            ).df()['patient_id']))        
    cvd_list.update(set(con.sql(f"SELECT DISTINCT patient_id \
                           FROM cmbd_incidents_long_view sub \
                               WHERE code IN {to_list(to_cvd_change_list)} \
                                   AND admission_date <= (SELECT dx_date \
                        FROM patient_incidents_view \
                            WHERE patient_incidents_view.patient_id = sub.patient_id);"
                            ).df()['patient_id']))        
      
    
    cvd_list = list(cvd_list)
    hf_list = list(hf_list.difference(cvd_list))
    ckd_list = list(ckd_list.difference(cvd_list+hf_list))
    f_list = list(f_list.difference(cvd_list+hf_list+ckd_list))
    ob_list = list(ob_list.difference(cvd_list+hf_list+ckd_list+f_list))
    else_list = list(set(con.sql("SELECT DISTINCT patient_id \
                                 FROM patient_incidents_view"
                                 ).df()['patient_id']
                         ).difference(cvd_list+hf_list+ckd_list+f_list+ob_list))
               
    # When is a change on predominant clinical condition made?  
    con.sql("DROP VIEW IF EXISTS cmbd_incidents_long_view_dx")
    con.sql(f"CREATE VIEW cmbd_incidents_long_view_dx AS SELECT * \
            FROM cmbd_incidents_long_view sub \
                WHERE admission_date > (SELECT dx_date \
                    FROM patient_incidents_view \
                        WHERE patient_incidents_view.patient_id = sub.patient_id);")

    query_function =  lambda cond: "(WITH rankedevents_*** AS (\
        SELECT patient_id,code,admission_date,ROW_NUMBER() \
          OVER(PARTITION BY patient_id ORDER BY admission_date,relevance) AS event_rank \
              FROM cmbd_incidents_long_view_dx WHERE  patient_id IN {to_list(***_list)} \
                  AND code IN {to_list(from_***_change_list)} ) \
            SELECT patient_id, '***' AS type,code, admission_date AS date \
                FROM rankedevents_*** WHERE  event_rank=1 AND date<'2023-01-01') \
                                    UNION ALL (WITH rankedevents__*** AS (\
        SELECT patient_id,code,admission_date,ROW_NUMBER() \
          OVER(PARTITION BY patient_id ORDER BY admission_date) AS event_rank \
              FROM cmbd_incidents_long_view_dx WHERE  patient_id IN {to_list(***_list)} \
                  AND code IN {to_list(['end']+from_***_change_list)} ) \
            SELECT patient_id, '***' AS type,code, admission_date AS date \
                FROM rankedevents__*** WHERE  event_rank=1 AND code='end')\
                ".replace('***',cond)
    con.sql("DROP TABLE IF EXISTS patient_condition;")    
    con.sql(eval('f"CREATE TABLE patient_condition AS {}"'.format(' UNION ALL '.join(
        [query_function(cond) for cond in ['cvd','hf','ckd','f','ob','else']]))))    
    return presc_data_p
                

def evlog_creation_by_prescriptions(con,
                                 cond,
                                 code2drug_info_path='./diabetes_drugs.csv'):
    '''Preprocessing and event log obtention with prescriptions
  
    Args:
      con : db connector variable
      cond (str): predominal clinical condition's code
      code2drug_info_path (str): drugs' and their codes' info's table's path
  
    ADNI: ANTIDIABETICOS NO INSULINICOS
  
    The treatment of type 2 diabetes mellitus with ADNI includes a wide range of 
    drugs which, depending on their drugs which, according to their mechanisms of 
    action, can be grouped as follows: 
     Increased endogenous insulin sensitivity:
        o Biguanides: metformin (MET).
        o Thiazolidinediones: pioglitazone (PIO).
     Increased endogenous insulin secretion/release:
        o Sulfonylureas (SU).
        o Meglitinides: repaglinide (REP)
     Reduction of digestive glucose absorption:
        o Alpha-glucosidase inhibitors.
        o Vegetable fiber and derivatives.
     Incretin effect enhancers.
        o Inhibitors of DPP-4 (iDPP-4).
        o GLP-1 analogues (aGLP-1).
     Inhibitors of renal glucose reuptake
        o SGLT-2 inhibitors (iSGLP-2)

    '''
    con.sql(f"DROP TABLE IF EXISTS evlog_raw_{cond}")
    fin_date = con.sql(f"SELECT patient_id,date FROM patient_condition \
                       WHERE type = '{cond}'").df()
    dx_date = con.sql(f"SELECT patient_id, dx_date FROM  patient_incidents_view \
                      WHERE patient_id IN (SELECT patient_id \
                         FROM patient_condition \
                             WHERE patient_condition.type = '{cond}')").df()
    dx_date = dict(zip(dx_date.patient_id,dx_date.dx_date))
    fin_date = dict(zip(fin_date.patient_id,fin_date.date))
    code2drug = pd.read_csv(code2drug_info_path,index_col=0).to_dict()
    code2drug_f = lambda atc: code2drug.get(atc,{'class':'NONE'}
                                           ).get('class','NONE2'
                                                 ).replace('+','&')
    treat_df = con.sql(f"SELECT * FROM treat_incidents_view \
                       WHERE patient_id IN (SELECT patient_id \
                                            FROM patient_condition \
                                                WHERE patient_condition.type = '{cond}') \
                           AND substring(atc_code,1,3) = 'A10'").df()
    treat_df['Event'] = treat_df['atc_code'].apply(code2drug_f)
    treat_df = treat_df[~treat_df['Event'].isin(['NONE','NONE2'])
                        ].drop_duplicates(subset=['patient_id',
                                                  'prescription_date_ini',
                                                  'prescription_date_end',
                                                  'Event'])
    treat_df['actins'] = range(len(treat_df))
    treat_df_start = treat_df[['patient_id','prescription_date_ini',
                              'Event','actins']].rename(columns = 
                                       {'prescription_date_ini':'date'})
    treat_df_end = treat_df[['patient_id','prescription_date_end',
                              'Event','actins']].rename(columns = 
                                       {'prescription_date_end':'date'})
    treat_df_start['cycle'] = 'start'
    treat_df_end['cycle'] = 'end'
    treat_df_end['date'] = treat_df_end['date'].fillna(
        datetime.strptime('2022-12-31', "%Y-%m-%d")).apply(
        lambda x: min([x,datetime.strptime('2023-01-01', "%Y-%m-%d")])).apply(
                                              lambda x: x-timedelta(days=1))
    act_n = max(treat_df['actins'])
    if cond in ['cvd','hf','ckd','f']:
        param_df = con.sql(f"SELECT patient_id,param_date AS date, \
                           CASE WHEN param_value < {8} THEN 'HBA<L' \
                               WHEN param_value >= {8} AND param_value < {8.5} \
                                   AND param_date < turn_to_65 THEN 'HBA>L' \
                               WHEN param_value >= {8} AND param_value < {8.5} \
                                   AND param_date >= turn_to_65 THEN 'HBA<L' \
                               ELSE 'HBA>L' END AS Event,\
                           ROW_NUMBER() OVER (ORDER BY param_date) + {act_n} AS actins\
                               FROM param_incidents_view_age_date \
                                   WHERE patient_id IN (SELECT patient_id \
                                    FROM patient_condition \
                                        WHERE patient_condition.type = '{cond}') \
                                    AND param_name = 'hba1c' \
                                    AND param_value IS NOT NULL").df()
    else:
        param_df = con.sql(f"SELECT patient_id,param_date AS date, \
                           CASE WHEN param_value < {7} THEN 'HBA<L' \
                               WHEN param_value >= {7} AND param_value < {8.5} \
                                   AND param_date < turn_to_75 THEN 'HBA>L' \
                               WHEN param_value >= {7} AND param_value < {8.5} \
                                   AND param_date >= turn_to_75 THEN 'HBA<L' \
                               ELSE 'HBA>L' END AS Event,\
                           ROW_NUMBER() OVER (ORDER BY param_date) + {act_n} AS actins\
                               FROM param_incidents_view_age_date \
                                   WHERE patient_id IN (SELECT patient_id \
                                    FROM patient_condition \
                                        WHERE patient_condition.type = '{cond}') \
                                    AND param_name = 'hba1c' \
                                    AND param_value IS NOT NULL").df()        

    param_df_start = param_df.copy()
    param_df_start['cycle'] = 'start'
    param_df_end = param_df.copy()
    param_df_end['cycle'] = 'end'

    df = pd.concat([param_df_start,treat_df_start,param_df_end,treat_df_end]
                   ).drop_duplicates()
    
    df = df.sort_values(by = ['patient_id','date','Event','cycle'],
                        ascending = [True,True,True,False])
    df.index = range(len(df))
    patient_list = list(set(df['patient_id']))
    df['nid'] = [patient_list.index(df['patient_id'][n]) for n in range(len(df))]

    #####################################################################
    
    event_log = dict()
    event_log['patient_id'] = []
    event_log['date'] = []
    event_log['nid'] = []
    event_log['Event'] = []
    event_log['cycle'] = []
    days_after_m = 5
    id_list = list(set(df['patient_id']))
    events = list(set([drug for e in set(df['Event']) for drug in e.split('&')]))
    hba0, hba1 = events.index('HBA<L'), events.index('HBA>L')
    row = len(events)
    no_hba = [i for i in range(row) if i not in [hba0,hba1]]
    for id in tqdm(id_list):
        df_id = df[df['patient_id']==id]
        nid = id_list.index(id)
        actins = set(df_id['actins'])
        date_min = min([min(set(df_id['date'])),dx_date[id]])
        date_max =  max(set(df_id['date']))
        if str(fin_date[id])!='nan':
            date_max = max([date_max,fin_date[id]])
        else:
            date_max = max([date_max,datetime.strptime('2023-01-01', "%Y-%m-%d")])
        dd = [date_min + timedelta(days=x) for x in range(
          (date_max-date_min).days + 1)]
        col = len(dd)
        ev_status = np.zeros((row,col))
        for act in actins:
            ini = list(df_id['date'][np.logical_and(df_id['actins']==act,
                                                  df_id['cycle']=='start')])[0]
            ev =  list(df_id['Event'][df_id['actins']==act])[0]            
            fin = list(df_id['date'][np.logical_and(df_id['actins']==act,
                                                  df_id['cycle']=='end')])[0]
            ev_cols = [events.index(ev_) for ev_ in ev.split('&')]
            ev_status = change_matrix_values(ev_status,ev_cols,
                                             list(range(dd.index(ini),
                                                        dd.index(fin)+1)),1)
                            
        measures = list(np.concatenate((ev_status[hba0,:].nonzero()[0],
                                        ev_status[hba1,:].nonzero()[0])))
        ev_status = ev_status.astype(int)              
        #delete treatments in measure events        
        ev_status = change_matrix_values(ev_status,no_hba,measures,0)
        #correction to eliminate events after hemoglobin measurement that are
        #the continuation of the previous treatment and not the new treatment.
        #Example: If a patient has 'A' treatment and because of hemoglobin's
        #         measure they change their treatment to 'B', originally their
        #         trace could appear as A>measure>A>B, but the true trace
        #         should be A>measure>B. Therefore, in a fixed period time 
        #         after each measurement 'days_after_m', if we detect that 
        #         mistake we delete it. 

        for j in measures:
            if ev_status.shape[1]<=j+1 or days_after_m<3:
                continue
            first_col = ev_status[:,j+1]
            dif_col = np.where(np.any(ev_status[:, j+2:j+days_after_m]!=
                                      first_col[:, np.newaxis],
                                      axis=0))[0]
          
            if  (dif_col.size > 0) and (not
                    np.array_equal(ev_status[:,j-1],
                                    ev_status[:,j+dif_col[0]+2])) and (
                    np.array_equal(ev_status[:,j-1],
                                    ev_status[:,j+1])):
                ev_status = change_matrix_values(ev_status,no_hba,
                                                  range(j+1,j+dif_col[0]+2),0)

          
        col = dd.index(dx_date[id])
        col_0 = dd.index(dx_date[id])
        col_max = dd.index(fin_date[id]) if str(fin_date[id])!='nan' else len(dd)
        min_change_days = 7
        while col<col_max-1:
            if not np.array_equal(ev_status[:,col],ev_status[:,col+1]):
                ev = col2treat(ev_status,events,col_0)
                if  ('HBA' not in ev and col-col_0<min_change_days):
                    col+=1
                    col_0 = col
                    continue
                event_log['patient_id'].extend([id,id])
                event_log['date'].extend([dd[col_0],dd[col]])
                event_log['Event'].extend([ev,ev])
                event_log['nid'].extend([nid,nid])
                event_log['cycle'].extend(['start','end'])
                
                col+=1
                col_0 = col
            else:
                col+=1
        ev = col2treat(ev_status,events,col_0)
        if 'HBA' in ev or col-col_0>=min_change_days:
            event_log['patient_id'].extend([id,id])
            event_log['date'].extend([dd[col_0],dd[col]])
            event_log['Event'].extend([ev,ev])
            event_log['nid'].extend([nid,nid])
            event_log['cycle'].extend(['start','end'])
    
            
    evlog = pd.DataFrame.from_dict(event_log)   
    evlog = evlog.sort_values(['patient_id','date'])
    evlog.rename(columns = {'patient_id':'ID'}, inplace = True)
    evlog.index = range(len(evlog))
    evlog['cycle'] = ['start','end']*int(0.5*len(evlog))
    evlog['actins'] = [n//2 for n in range(len(evlog))]
    con.sql(f"CREATE TABLE evlog_raw_{cond} AS SELECT * FROM evlog")
 
def evlog_creation_by_dispensations(con, 
                              cond,
                              code2drug_info_path='./diabetes_drugs.csv',
                              nac_path='./Nomenclator_de_Facturacion.csv'):
    '''Preprocessing and event log obtention with dispensations

    Args:
      con : db connector variable
      cond (str): predominal clinical condition's code
      code2drug_info_path (str): drugs' and their codes' info's table's path
      nac_path (str): drugs' and their containers' info's table's path
    
    ADNI: ANTIDIABETICOS NO INSULINICOS
    
    The treatment of type 2 diabetes mellitus with ADNI includes a wide range of 
    drugs which, depending on their drugs which, according to their mechanisms of 
    action, can be grouped as follows: 
     Increased endogenous insulin sensitivity:
        o Biguanides: metformin (MET).
        o Thiazolidinediones: pioglitazone (PIO).
     Increased endogenous insulin secretion/release:
        o Sulfonylureas (SU).
        o Meglitinides: repaglinide (REP)
     Reduction of digestive glucose absorption:
        o Alpha-glucosidase inhibitors.
        o Vegetable fiber and derivatives.
     Incretin effect enhancers.
        o Inhibitors of DPP-4 (iDPP-4).
        o GLP-1 analogues (aGLP-1).
     Inhibitors of renal glucose reuptake
        o SGLT-2 inhibitors (iSGLP-2)
    
    '''

    con.sql(f"DROP TABLE IF EXISTS evlog_raw_{cond}")
    treat_min_days = 2
    days_error = 60-treat_min_days
    days_after_m = 7
    fin_date = con.sql(f"SELECT patient_id,date FROM patient_condition \
                       WHERE type = '{cond}'").df()
    dx_date = con.sql(f"SELECT patient_id, dx_date FROM  patient_incidents_view \
                      WHERE patient_id IN (SELECT patient_id \
                         FROM patient_condition \
                             WHERE patient_condition.type = '{cond}')").df()
    dx_date = dict(zip(dx_date.patient_id,dx_date.dx_date))
    fin_date = dict(zip(fin_date.patient_id,fin_date.date))
    code2drug = pd.read_csv(code2drug_info_path,index_col=0).to_dict()
    code2drug_f = lambda atc: code2drug.get(atc,{'class':'NONE'}
                                           ).get('class','NONE2'
                                                 ).replace('+','&')
    treat_df = con.sql(f"SELECT * FROM treat_incidents_view \
                       WHERE patient_id IN (SELECT patient_id \
                                            FROM patient_condition \
                                                WHERE patient_condition.type = '{cond}') \
                           AND substring(atc_code,1,3) = 'A10'").df()
    treat_df['Event'] = treat_df['atc_code'].apply(code2drug_f)
    treat_df = treat_df[~treat_df['Event'].isin(['NONE','NONE2'])]
    nac_dict = nac2comprimidos(nac_path,set(treat_df['nac_code']))
    treat_df['nac_code'] = treat_df['nac_code'].apply(
        lambda x: nac_dict.get(x,days_error))
    treat_df['containers_number'] = treat_df['containers_number'].fillna(1)
    treat_df['nac_code'] = treat_df['nac_code']*treat_df['containers_number']
    treat_df = treat_df[['patient_id','dispensing_date','Event','nac_code']
                        ].rename(columns = {'dispensing_date':'date'}
                                 ).sort_values(by = ['patient_id','date' ],
                      ascending = [True, True])
                     
    if cond in ['cvd','hf','ckd','f']:
        df = con.sql(f"SELECT *, 'start' AS cycle,\
                     ROW_NUMBER() OVER (ORDER BY patient_id, date) AS actins \
                         FROM (SELECT patient_id,param_date AS date, \
                           CASE WHEN param_value < {8} THEN 'HBA<L' \
                                WHEN param_value >= {8} AND param_value < {8.5} \
                                   AND param_date < turn_to_65 THEN 'HBA>L' \
                                WHEN param_value >= {8} AND param_value < {8.5} \
                                   AND param_date >= turn_to_65 THEN 'HBA<L' \
                                ELSE 'HBA>L' END AS Event, 0 AS nac_code\
                               FROM param_incidents_view_age_date \
                                   WHERE patient_id IN (SELECT patient_id \
                                    FROM patient_condition \
                                        WHERE patient_condition.type = '{cond}') \
                                       AND param_name = 'hba1c' \
                                    AND param_value IS NOT NULL \
                                UNION ALL SELECT * FROM treat_df) \
                    UNION ALL SELECT patient_id, date, Event, nac_code, 'end' AS cycle,\
                     ROW_NUMBER() OVER (ORDER BY patient_id, param_date) AS actins \
                         FROM (SELECT patient_id,param_date AS date, param_date,\
                           CASE WHEN param_value < {8} THEN 'HBA<L' \
                                WHEN param_value >= {8} AND param_value < {8.5} \
                                   AND param_date < turn_to_65 THEN 'HBA>L' \
                                WHEN param_value >= {8} AND param_value < {8.5} \
                                   AND param_date >= turn_to_65 THEN 'HBA<L' \
                                ELSE 'HBA>L' END AS Event, 0 AS nac_code\
                               FROM param_incidents_view_age_date \
                                   WHERE patient_id IN (SELECT patient_id \
                                    FROM patient_condition \
                                        WHERE patient_condition.type = '{cond}') \
                                       AND param_name = 'hba1c' \
                                    AND param_value IS NOT NULL \
                                UNION ALL SELECT patient_id,\
                                CAST(date AS TIMESTAMP)+INTERVAL {treat_min_days} \
                                    DAYS AS date, date AS param_date, \
                                        Event, nac_code FROM treat_df)").df()
    else:
        df = con.sql(f"SELECT *, 'start' AS cycle,\
                     ROW_NUMBER() OVER (ORDER BY patient_id, date) AS actins \
                         FROM (SELECT patient_id,param_date AS date, \
                           CASE WHEN param_value < {7} THEN 'HBA<L' \
                                WHEN param_value >= {7} AND param_value < {8.5} \
                                   AND param_date < turn_to_75 THEN 'HBA>L' \
                                WHEN param_value >= {7} AND param_value < {8.5} \
                                   AND param_date >= turn_to_75 THEN 'HBA<L' \
                                ELSE 'HBA>L' END AS Event, 0 AS nac_code\
                               FROM param_incidents_view_age_date \
                                   WHERE patient_id IN (SELECT patient_id \
                                    FROM patient_condition \
                                        WHERE patient_condition.type = '{cond}') \
                                       AND param_name = 'hba1c' \
                                    AND param_value IS NOT NULL \
                                UNION ALL SELECT * FROM treat_df) \
                    UNION ALL SELECT patient_id, date, Event, nac_code, 'end' AS cycle,\
                     ROW_NUMBER() OVER (ORDER BY patient_id, param_date) AS actins \
                         FROM (SELECT patient_id,param_date AS date, param_date,\
                           CASE WHEN param_value < {7} THEN 'HBA<L' \
                                WHEN param_value >= {7} AND param_value < {8.5} \
                                   AND param_date < turn_to_75 THEN 'HBA>L' \
                                WHEN param_value >= {7} AND param_value < {8.5} \
                                   AND param_date >= turn_to_75 THEN 'HBA<L' \
                                ELSE 'HBA>L' END AS Event, 0 AS nac_code\
                               FROM param_incidents_view_age_date \
                                   WHERE patient_id IN (SELECT patient_id \
                                    FROM patient_condition \
                                        WHERE patient_condition.type = '{cond}') \
                                       AND param_name = 'hba1c' \
                                    AND param_value IS NOT NULL \
                                UNION ALL SELECT patient_id,\
                                CAST(date AS TIMESTAMP)+INTERVAL {treat_min_days} \
                                    DAYS AS date, date AS param_date, \
                                        Event, nac_code FROM treat_df)").df()

    patient_list = list(set(df['patient_id']))
    df['nid'] = [patient_list.index(df['patient_id'][n]) for n in range(len(df))] 
    df = df.sort_values(by = ['patient_id', 'actins','cycle'],
                        ascending = [True, True, False])
    df.index = range(len(df))
    
    #####################################################################

    event_log = dict()
    event_log['patient_id'] = []
    event_log['date'] = []
    event_log['nid'] = []
    event_log['Event'] = []
    event_log['cycle'] = []
    
    id_list = list(set(df['patient_id']))
    events = list(set([drug for e in set(df['Event']) for drug in e.split('&')]))
    hba0, hba1 = events.index('HBA<L'), events.index('HBA>L')
    row = len(events)
    no_hba = [i for i in range(row) if i not in [hba0,hba1]]
    for id in tqdm(id_list):
        df_id = df[df['patient_id']==id]
        nid = id_list.index(id)
        actins = set(df_id['actins'])
        date_min = min([min(set(df_id['date'])),dx_date[id]])
        date_max =  max(set(df_id['date']))
        if str(fin_date[id])!='nan':
            date_max = max([date_max,fin_date[id]])
        else:
            date_max = max([date_max,datetime.strptime('2023-01-01', "%Y-%m-%d")])
        dd = [date_min + timedelta(days=x) for x in range(
          (date_max-date_min).days + 1)]
        col = len(dd)
        ev_status = np.zeros((row,col))
        max_nac = int(max(df_id['nac_code'])*1.2)
        #event matrix where columns are days and rows treatments
        #0:no treatment, 1:treatment, 2:posible treatment,
        #3:after measuring period
        for act in actins:
            ini = list(df_id['date'][np.logical_and(df_id['actins']==act,
                                                  df_id['cycle']=='start')])[0]
            ev =  list(df_id['Event'][df_id['actins']==act])[0]            
            fin = ini+timedelta(days=treat_min_days) if 'HBA' not in ev else ini
            ev_cols = [events.index(ev_) for ev_ in ev.split('&')]
            ev_status = change_matrix_values(ev_status,ev_cols,
                                             list(range(dd.index(ini),
                                                        dd.index(fin)+1)),1)
            if 'HBA' not in ev:
                possible_day_duration = int(list(
                    df_id['nac_code'][np.logical_and(df_id['actins']==act,
                    df_id['cycle']=='start')])[0]*1.2)
                until_day = min([dd.index(ini)+possible_day_duration,col])
                ev_status = change_matrix_values(ev_status,ev_cols,
                                                 list(range(dd.index(fin),
                                                            until_day)),2)
                            
                                        
                
                
        measures = list(np.concatenate((ev_status[hba0,:].nonzero()[0],
                                        ev_status[hba1,:].nonzero()[0])))
        #event compaction.
        #Example: If a patient has 'A' treatment and they are dispensing 'A'
        #         drug multiple times, their trace could appear as A>A>A>A, 
        #         but the true trace should appear as 'A' treatment lasting
        #         its corresponding time. Therefore, if the difference between
        #         the last day and the first day of two consecutive same drugs's
        #         dispensation is less than the number of tablets of the 
        #         container two events are jointed in one with the first day of
        #         the first event as initial date and last day of the last 
        #         event as the end date.
        ev_status = ev_status.astype(int)
        for i in no_hba:
            seq = str(list(ev_status[i,:]))
            for delta_days in range(1,max_nac):
                pattern = ', '+str([1]+[2]*delta_days+[1])[1:-1]
                new_pattern = ', '+str([1]+[1]*delta_days+[1])[1:-1]
                seq = seq.replace(pattern,new_pattern)
            ev_status[i,:] = eval(seq) 
              
        ev_status = change_matrix_values(ev_status,no_hba,measures,3)
        for i,j in list(itertools.combinations(no_hba,2)):
            seq_i = str(list(ev_status[i,:]))
            seq_j = str(list(ev_status[j,:]))
            for delta_days in range(1,max_nac):
                pattern_i = ', '+str([1]+[1]*delta_days+[3])[1:-1]
                if re.search(pattern_i,seq_i)==None:
                    continue
                pattern_j = ', '+str([1]+[2]*delta_days+[3])[1:-1]
                new_pattern_j = ', '+str([1]+[1]*delta_days+[3])[1:-1]
                seq_j = seq_j.replace(pattern_j,new_pattern_j)
            for delta_days in range(1,max_nac):
                pattern_j = ', '+str([1]+[1]*delta_days+[3])[1:-1]
                if re.search(pattern_j,seq_j)==None:
                    continue
                pattern_i = ', '+str([1]+[2]*delta_days+[3])[1:-1]
                new_pattern_i = ', '+str([1]+[1]*delta_days+[3])[1:-1]
                seq_i = seq_i.replace(pattern_i,new_pattern_i)
            ev_status[i,:] = eval(seq_i)
            ev_status[j,:] = eval(seq_j)

        measures_w_dp = [[i+d_p for d_p in range(days_after_m+1)
                          if i+d_p<col] for i in measures]    
        measures_w_dp = list(itertools.chain(*measures_w_dp))
        ev_status = change_matrix_values(ev_status,no_hba,measures_w_dp,3)

        for i in no_hba:
            seq = str(list(ev_status[i,:]))
            seq = seq.replace('2','0').replace('3','0')
            ev_status[i,:] = eval(seq)               
                
        col = dd.index(dx_date[id])
        col_0 = dd.index(dx_date[id])
        col_max = dd.index(fin_date[id]) if str(fin_date[id])!='nan' else len(dd)
        min_change_days = 42
        while col<col_max-1:
            if not np.array_equal(ev_status[:,col],ev_status[:,col+1]):
                ev = col2treat(ev_status,events,col_0)
                if  (ev=='_' and col-col_0<min_change_days):
                    col+=1
                    col_0 = col
                    continue
                event_log['patient_id'].extend([id,id])
                event_log['date'].extend([dd[col_0],dd[col]])
                event_log['Event'].extend([ev,ev])
                event_log['nid'].extend([nid,nid])
                event_log['cycle'].extend(['start','end'])
                
                col+=1
                col_0 = col
            else:
                col+=1
        ev = col2treat(ev_status,events,col_0)
        if ev!='_' or col-col_0>=min_change_days:
            event_log['patient_id'].extend([id,id])
            event_log['date'].extend([dd[col_0],dd[col]])
            event_log['Event'].extend([ev,ev])
            event_log['nid'].extend([nid,nid])
            event_log['cycle'].extend(['start','end'])
    
            
    evlog = pd.DataFrame.from_dict(event_log)   
    evlog = evlog.sort_values(['patient_id','date'])
    evlog.rename(columns = {'patient_id':'ID'}, inplace = True)
    evlog.index = range(len(evlog))
    evlog['cycle'] = ['start','end']*int(0.5*len(evlog))
    evlog['actins'] = [n//2 for n in range(len(evlog))]
    con.sql(f"CREATE TABLE evlog_raw_{cond} AS SELECT * FROM evlog")
  
def change_matrix_values(matrix,list_rows,list_cols, new_value=0):
    '''change selected rows' and columns' matrix`s values
    Args:
      matrix (array): matrix wanted to modify
      list_rows (list): matrix's rows wanted to modify
      list_cols (list): matrix's columns wanted to modify
      new_value (int): new wanted value
      
    Output:
      matrix (array): modified matrix
    '''
    pos = list(itertools.product(list_rows,list_cols))
    for i,j in pos:
        matrix[i,j] = new_value
    return matrix

def col2treat(matrix,rows,col):
    '''translate treatments from a binary vector
  
    Args:
      matrix (array): events calendary in binary information
      rows (str): events list
      col (int): column of matrix wanted to translate
    
    Output:
      treatment (str):
    '''
    treatment = '+'.join(sorted([rows[ev
                            ] for ev in range(len(rows)) 
                                 if matrix[ev,col]!=0]))
    if treatment!='':
        return treatment
    else:
        return '_'
    
def nac2comprimidos(nac_path,code_set):
    '''Creating dictionary of nac drugs container's number of tablets
  
    Args:
      nac_path (str): nac table's path
      code_set (set): nac code list
    Outputs:
        nac_dict (dic): nac codes as keys and their number of tablets as values
    '''

    nac = pd.read_csv(nac_path)
    nac['Código Nacional'] = nac['Código Nacional'].astype(str)
    nac_dict = {}

    for n in range(len(nac)):
        if nac['Código Nacional'][n] in code_set:
            text = nac['Nombre del producto farmacéutico'][n].lower()
            if re.search(r'\d+(?=\s*comprim)', text)!=None:
                nac_dict[nac['Código Nacional'][n]
                         ] = int(re.search(r'\d+(?=\s*comprim)', text).group())
            elif re.search(r'\d+(?=\s*comprim)', 
                           re.sub(r'\([^()]*\)', '', text))!=None:
                nac_dict[nac['Código Nacional'][n]
                         ] = int(re.search(r'\d+(?=\s*comprim)', 
                                re.sub(r'\([^()]*\)', '', text)).group())          
            elif re.search(r'con pelicula (\d+)', text)!=None:
                nac_dict[nac['Código Nacional'][n]
                         ] = int(re.search(r'con pelicula (\d+)',
                                    text).group().split()[-1])
    return nac_dict
```


### Process indicators' event log creation

With the objective of studying process indicators a function to make a process indicators' event log is coded above. There, in addition to laboratory measures and realized exams, three artificial events have been included to aid the analysis.'INI' event denotes each patient's diabetes diagnosis date, 'yFIN' events indicate the end of each annual interval and 'FIN' event is the date of the end of the last completed annual interval.

```{python, warning: FALSE}
#| label: process indicators' event log creation
#| warning: FALSE
def evlog_process_ind(con):
    '''Generation of process indicators' eventlog

    Args:
      con : db connector variable
    '''
    con.sql("DROP VIEW IF EXISTS pre_process_ind;")
    con.sql("DROP TABLE IF EXISTS process_ind;")
    con.sql("DROP TABLE IF EXISTS process_ind1;")
    con.sql("DROP TABLE IF EXISTS process_ind2;")
    con.sql("DROP TABLE IF EXISTS process_ind3;")
    con.sql("DROP TABLE IF EXISTS process_ind4;")
    con.sql("DROP TABLE IF EXISTS process_ind5;")


    
    con.sql("CREATE VIEW pre_process_ind AS SELECT *,'start' AS cycle,\
                ROW_NUMBER() OVER (ORDER BY patient_id,date) AS actins \
            FROM (SELECT DISTINCT patient_id,'hba1c' AS event, \
            CAST(param_date AS TIMESTAMP) + INTERVAL 60 SECOND AS date \
            FROM param_incidents_view WHERE param_name = 'hba1c' \
            UNION ALL SELECT DISTINCT patient_id,'col' AS event, \
                    CAST(param_date AS TIMESTAMP) + INTERVAL 120 SECOND AS date \
            FROM param_incidents_view WHERE param_name IN  ('col','hdl','ldl') \
            UNION ALL SELECT DISTINCT patient_id,'blood_p' AS event, \
                    CAST(param_date AS TIMESTAMP) + INTERVAL 180 SECOND AS date \
            FROM param_incidents_view WHERE param_name IN  ('sbp','dbp') \
            UNION ALL SELECT DISTINCT patient_id,'indalbcr' AS event, \
                    CAST(param_date AS TIMESTAMP) + INTERVAL 240 SECOND AS date \
            FROM param_incidents_view WHERE param_name='indalbcr' \
            UNION ALL SELECT DISTINCT patient_id,'filtglom' AS event, \
                    CAST(param_date AS TIMESTAMP) + INTERVAL 300 SECOND AS date \
            FROM param_incidents_view WHERE param_name='filtglom' \
            UNION ALL SELECT DISTINCT patient_id,'bmi' AS event, \
                    CAST(param_date AS TIMESTAMP) + INTERVAL 360 SECOND AS date \
            FROM param_incidents_view WHERE param_name IN ('bmi','weight') \
            UNION ALL SELECT DISTINCT patient_id,'ocular_exam' AS event, \
                    CAST(test_date AS TIMESTAMP) + INTERVAL 420 SECOND AS date \
            FROM exams_incidents_view WHERE test_name='ocular_exam_PC' \
            UNION ALL SELECT DISTINCT patient_id,'foot_exam' AS event, \
                    CAST(test_date AS TIMESTAMP) + INTERVAL 480 SECOND AS date \
            FROM exams_incidents_view WHERE test_name='foot_exam' \
            UNION ALL SELECT patient_id,'INI' AS event, \
                    CAST(dx_date AS TIMESTAMP) AS date \
            FROM patient_incidents_view \
            UNION ALL SELECT patient_id, 'yFIN' AS event,\
                    CAST(dx_date AS TIMESTAMP) + INTERVAL 365 DAYS AS date \
            FROM patient_incidents_view \
            UNION ALL SELECT patient_id, 'yFIN' AS event,\
                    CAST(dx_date AS TIMESTAMP) + INTERVAL 730 DAYS AS date \
            FROM patient_incidents_view \
            UNION ALL SELECT patient_id, 'yFIN' AS event,\
                    CAST(dx_date AS TIMESTAMP) + INTERVAL 1095 DAYS AS date \
            FROM patient_incidents_view \
            UNION ALL SELECT patient_id, 'yFIN' AS event,\
                    CAST(dx_date AS TIMESTAMP) + INTERVAL 1461 DAYS AS date \
            FROM patient_incidents_view \
            UNION ALL SELECT patient_id, 'yFIN' AS event,\
                    CAST(dx_date AS TIMESTAMP) + INTERVAL 1826 DAYS AS date \
            FROM patient_incidents_view \
            UNION ALL SELECT patient_id, 'FIN' AS event,\
                    CAST(COALESCE(deregistration_date,'2023-01-01') AS TIMESTAMP) AS date \
            FROM patient_incidents_view)") 
    
    
    
    
    con.sql("CREATE TABLE process_ind AS SELECT a.* FROM pre_process_ind a \
            JOIN (SELECT patient_id, MIN(date) as ini_date,MAX(date) as fin_date \
            FROM pre_process_ind d WHERE event IN ('INI', 'yFIN') AND \
                date<(SELECT c.date FROM pre_process_ind c \
                      WHERE c.event = 'FIN' AND c.patient_id = d.patient_id) \
            GROUP BY patient_id) b ON a.patient_id = b.patient_id \
            WHERE (a.date BETWEEN b.ini_date AND b.fin_date) OR a.event = 'FIN'")
    con.sql("CREATE TABLE process_ind1 AS SELECT * FROM \
            (WITH RankedActions AS (SELECT patient_id, date, event,\
                    ROW_NUMBER() OVER (PARTITION BY patient_id ORDER BY date) AS rn \
                        FROM process_ind WHERE event = 'yFIN') \
             SELECT DISTINCT A.* FROM process_ind A \
                 JOIN RankedActions R ON A.patient_id = R.patient_id WHERE \
                     R.rn = 1 AND (A.date <= R.date OR A.event = 'FIN'))")  
    con.sql("CREATE TABLE process_ind2 AS SELECT * FROM \
            (WITH RankedActions AS (SELECT patient_id, date, event,\
                    ROW_NUMBER() OVER (PARTITION BY patient_id ORDER BY date) AS rn \
                        FROM process_ind WHERE event = 'yFIN') \
             SELECT DISTINCT A.* FROM process_ind A \
                 JOIN RankedActions R ON A.patient_id = R.patient_id WHERE \
                     R.rn = 2 AND (A.date <= R.date OR A.event = 'FIN'))")        
    con.sql("CREATE TABLE process_ind3 AS SELECT * FROM \
            (WITH RankedActions AS (SELECT patient_id, date, event,\
                    ROW_NUMBER() OVER (PARTITION BY patient_id ORDER BY date) AS rn \
                        FROM process_ind WHERE event = 'yFIN') \
             SELECT DISTINCT A.* FROM process_ind A \
                 JOIN RankedActions R ON A.patient_id = R.patient_id WHERE \
                     R.rn = 3 AND (A.date <= R.date OR A.event = 'FIN'))")        
    con.sql("CREATE TABLE process_ind4 AS SELECT * FROM \
            (WITH RankedActions AS (SELECT patient_id, date, event,\
                    ROW_NUMBER() OVER (PARTITION BY patient_id ORDER BY date) AS rn \
                        FROM process_ind WHERE event = 'yFIN') \
             SELECT DISTINCT A.* FROM process_ind A \
                 JOIN RankedActions R ON A.patient_id = R.patient_id WHERE \
                     R.rn = 4 AND (A.date <= R.date OR A.event = 'FIN'))")        
    con.sql("CREATE TABLE process_ind5 AS SELECT * FROM \
            (WITH RankedActions AS (SELECT patient_id, date, event,\
                    ROW_NUMBER() OVER (PARTITION BY patient_id ORDER BY date) AS rn \
                        FROM process_ind WHERE event = 'yFIN') \
             SELECT DISTINCT A.* FROM process_ind A \
                 JOIN RankedActions R ON A.patient_id = R.patient_id WHERE \
                     R.rn = 5 AND (A.date <= R.date OR A.event = 'FIN'))") 
        
```

### Distances

One of the most important aim of process mining is to show and explain the processes. However, the great variety of traces does not allow us to draw any clear conclusions and it is often necessary to simplify our data. Another option that we can do before simplifying, to avoid the excessive losing of information and give another perspective to the analysis, is to cluster the traces and to analyze them by cluster. To do that we have to measure somehow the differences between the traces; the distance between them. There are some distances that we can use to this task: edit distances, vector term similarity, LDA based distances, embedding based distances... Some of them are shown below as functions to calculate the distance matrix of traces:

```{python}
#| label: Distance matrix functions

#######   EDIT DISTANCE   ####### 
def calculate_dm_ED(traces,measure_f):
    '''Calculate distance matrix with some edit distance.
    
    Args:
      traces (list): patients' traces
      measure_f: some edit distance function
      
    Returns:
      dm: distance matrix
    '''
    id2word = corpora.Dictionary(traces)

    traces_e = [[id2word.token2id[t[n]] for n in range(len(t))] for t in traces]
    traces_e_str = list(set([str(traces_e[i]
                                 ) for i in range(len(traces_e))]))    
    len_t_r = len(traces_e_str)
    len_t = len(traces_e)
    dm = np.zeros((len_t,len_t), dtype = np.float32)
    same = measure_f(traces_e[0],traces_e[0])
    d_dic = {str(t):dict() for t in traces_e_str}
    for i in range(len_t_r):
        d_dic[traces_e_str[i]][traces_e_str[i]] = same
        for j in range(i+1,len_t_r):
            d_ij = measure_f(eval(traces_e_str[i]),
                             eval(traces_e_str[j]))
            d_dic[traces_e_str[i]][traces_e_str[j]] = d_ij
            d_dic[traces_e_str[j]][traces_e_str[i]] = d_ij

    for i in range(len_t):
        dm[i][i] = same
        for j in range(i+1,len_t):
            t_i = str(traces_e[i])
            t_j = str(traces_e[j])            
            d_ij = d_dic[t_i][t_j]
            dm[i][j] = d_ij
            dm[j][i] = d_ij
    if same == 1:
        dm = 1 - dm  
    
    return dm

#######   TERM VECTOR SIMILARITY   #######      
def calculate_dm_TV(traces):
    '''Calculate distance matrix with term vector similarity.
    
    Args:
      traces (list): list of traces
      
    Returns:
      dm (array): distance matrix
      vectorizer: TfidfVectorizer
      X: traces vectorized with TfidVectorizer
        
    '''
    corpus = [' '.join(t) for t in traces]
    vectorizer = TfidfVectorizer(tokenizer=str.split)
    X = vectorizer.fit_transform(corpus)
    print('calculatin dm ...')
    dm = np.asarray(np.matmul(X.todense(),X.todense().T))
    dm = 1 - dm.round(decimals=4)           
    return dm, vectorizer, X

#######   LDA BASED DISTANCE   #######      
def calculate_dm_LDA(traces,T=10):
    '''Calculate distance matrix with LDA model.
    
    Args:
      traces (list): list of traces
      T (int): number of topics of LDA model
    Returns:
      dm (array): distance matrix
      lda_model: LdaModel
      id2word (dict): tokenized events as keys and events by values
        
    '''

    # Create Dictionary
    id2word = corpora.Dictionary(traces)
    
    # Term Document Frequency
    corpus = [id2word.doc2bow(text) for text in traces]
    # Make LDA model
    lda_model = LdaModel(corpus=corpus,
                         id2word=id2word,
                         num_topics=T,
                         alpha = 1,
                         eta = 'auto',
                         random_state = 123)
    get_c_topic = np.array(
        lda_model.get_document_topics(corpus,minimum_probability = -0.1))
    sigma = np.asarray([[get_c_topic[i][j][1] 
              for j in range(T)] for i in range(len(corpus))])

    sigma2 = np.asarray(np.matmul(sigma,sigma.T))
    len_t = len(traces)
    dm = np.zeros((len_t,len_t), dtype = np.float32)
    
    same = sigma2[0][0]/np.sqrt(sigma2[0][0]*sigma2[0][0])
    for i in trange(len_t):
        dm[i][i] = same
        for j in range(i+1,len_t):
            d_ij = sigma2[i][j]/np.sqrt(sigma2[i][i]*sigma2[j][j])
            dm[i][j] = d_ij
            dm[j][i] = d_ij
    
            

    dm = 1-dm
    return dm, lda_model, id2word

```

### Clustering

Once the distance matrix is obtained, we can proceed with the clustering. Each clustering method has its characteristics and its peculiarities. For example, we have to consider we have a distance matrix and not a data frame in which we apply directly the method. A hierarchical clustering algorithm seems to be a good choice in our case because in addition to the above it allows to choose the optimal number of clusters.

The next code box contains two different functions to choose the optimal number of clusters:

```{python}
#| label: Functions to choose optimal number of clusters
def dendogram(dm,output_png='../../outputs/dendogram.png'):
  '''Plot and save dendogram.
    
    Args:
      dm (array): distance matrix
      output_png (str): saved dendogram's path

  '''

  dm_condensed = squareform(dm)
  
  matrix = linkage(
      dm_condensed,
      method='complete'
      )
  sys.setrecursionlimit(10000000)
  dn = dendrogram(matrix,truncate_mode='lastp',p=80)
  sys.setrecursionlimit(1000)
  plt.title('Dendrogram')
  plt.ylabel('Distance')
  plt.xlabel('Patients traces')
  plt.savefig(output_png)
  plt.clf()

def kelbow(dm,
           elbow_metric='distortion',
           locate_elbow=False,
           output_path='../../outputs/'):
  
  '''Plots to choose optimal clusters.
    
    Args:
      dm (array): distance matrix
      elbow_metric (str): name of the method
      locate_elbow (boolean): True if want to return optimal number of clusters
    Returns:
      k_opt (int)(optional): optimal number of clusters according to method
  '''

  model = AgglomerativeClustering(metric = "precomputed",
                                  linkage = 'complete')
  # k is range of number of clusters.
  visualizer_ = KElbowVisualizer(model,
                                k=(2,25),
                                timings=False,
                                xlabel = 'cluster numbers',
                                metric=elbow_metric,
                                locate_elbow=locate_elbow)
  # Fit data to visualizer
  output_file = output_path+elbow_metric+'.png'
  visualizer_.fit(dm)
  # Finalize and render figure
  #visualizer_.show(output_path=output_file,clear_figure=False)
  visualizer_.show(output_path=output_file)
  k_opt=None
  if locate_elbow:
    k_opt = visualizer_.elbow_value_ 
    return k_opt
```

The function 'clust' clusterizes traces in prefixed number of clusters:

```{python}
def clust(clust_n,dist_matrix,df_,id2trace,patients):
  '''clusterize distance matrix.
    
    Args:
      clust_n (int): number of clusters obtained
      dist_matrix (array): distance matrix
      df_ (dataframe): event log
      id2trace (dict): patient ids as keys and their traces as values
      patients (list): patients' ids in same order as in dm
    Returns:
      df_ (dataframe): dataframe with patients and their clusters
  '''
  traces = list(id2trace[id] for id in sorted(id2trace.keys()))     


  model = AgglomerativeClustering(n_clusters=clust_n,
                                  metric = "precomputed",
                                  linkage = 'complete')
  model.fit(dist_matrix)
  labels = model.labels_

  cluster_list ={id: labels[traces.index(id2trace[id])
                            ] for id in patients}

  df_['cluster'] = [cluster_list[df_['ID'][i]] for i in range(len(df_))]
  return df_
```

### Descriptive analysis of treatments' eventlog

The implementation below is made to show the most frequent traces in each cluster:

```{python}
#| label: Clusters visualization functions

def make_data_dict(log,top_k,col_id):
  '''Obtain most frequent traces and their statistics
    
    Args:
      log (dataframe): event log 
      top_k (int): number of traces want to show
      col_id (str): patients id column's name in df_
    Returns:
      data_dict (dict): traces as keys and ther statistics as values   
  '''

  len_id = len(set(log[col_id]))
  log_freq = pm4py.stats.get_variants(log)
  freq_list = [(t,log_freq[t],len(t)) for t in set(log_freq.keys())]
  trace = [list(t[0]) for t in sorted(freq_list, key=lambda x: 
                                              (len_id-x[1],x[2]))[:top_k]]
  cases = [t[1] for t in sorted(freq_list, key=lambda x: 
                                              (len_id-x[1],x[2]))[:top_k]]
  top_k = min(top_k,len(cases))
  percentage = [100*cases[c]/len_id for c in range(top_k)]
  cum_percentage = [sum(percentage[:p+1]) for p in range(top_k)]
  data_dict = {"Trace": trace,
               "Percentage": percentage,
               "Cases": cases,
               "Cumulative Percentage": cum_percentage}
  return data_dict
  
  
def update_color_dict(color_dict,data_dict):
  '''update of the color dict to include new events
    
    Args:
      color_dict (dict): events as keys and colors as values 
      data_dict (dict):  traces as keys and ther statistics as values
    Returns:
      color_dict (dict): events as keys and colors as values    
  '''
  cmap = plt.cm.get_cmap('tab20')
  for event in set(itertools.chain.from_iterable(data_dict['Trace'])):
      if event not in color_dict and len(color_dict)==20:
         cmap = plt.cm.get_cmap('tab20b')
      if event not in color_dict:    
        try:
          color_dict.update({event:cmap(len(color_dict))})
        except:
          color_dict.update({event:cmap(2*(len(color_dict)-20))})
  return color_dict 


def trace_plotter(data_dict,
                  color_dict,
                  acronym,
                  output_file,
                  font_size=10,
                  percentage_box_width=0.8,
                  size=(15,9)):
  '''configuration of the trace_explorer plot
    
    Args:
      color_dict (dict): events as keys and colors as values 
      data_dict (dict):  traces as keys and their statistics as values
      acronym (dict): events as keys and their acronyms as values
      output_file (str): figure's path
      font_size (int): font size
      percentage_box_width (float): event boxes' width
      size (tuple): figure's size
  '''

  fig, ax = plt.subplots(figsize=size)
  percentage_position = max(len(t) for t in data_dict["Trace"]
                            ) + percentage_box_width*3 +0.5
  for row, (trace, percentage,cases,cum_percentage
            ) in enumerate(zip(data_dict["Trace"],
                               data_dict["Percentage"],
                               data_dict["Cases"],
                               data_dict["Cumulative Percentage"]),
                               start=1):
    for col, acr in enumerate(trace, start=1):
        ax.add_patch(plt.Rectangle((col - 0.5, row - 0.45), 1, 0.9,
                                    facecolor=color_dict[acr],
                                    edgecolor='white'))
        ax.text(col, 
                row, 
                acr, 
                ha='center', 
                va='center', 
                color='white',
                fontsize = font_size, 
                fontweight='bold')
        ax.add_patch(plt.Rectangle((
          percentage_position -percentage_box_width*2.5,
          row - 0.45), percentage_box_width, 0.9,
          facecolor='grey', edgecolor='white'))
        ax.text(percentage_position-percentage_box_width*2,
                row,
                f'{percentage:.2f}%',
                ha='center',
                va='center',
                color='white',
                fontsize = font_size+2)
        ax.add_patch(plt.Rectangle((
          percentage_position - percentage_box_width*1.5,
          row - 0.45), percentage_box_width, 0.9,
          facecolor='grey', edgecolor='white'))
        ax.text(percentage_position-percentage_box_width,
                row,
                f'{cases}',
                ha='center',
                va='center',
                color='white',
                fontsize = font_size+4)
        ax.add_patch(plt.Rectangle((percentage_position-percentage_box_width*0.5, 
                                    row - 0.45), percentage_box_width, 0.9,
                                    facecolor='grey', edgecolor='white'))
        ax.text(percentage_position,
                row,
                f'{cum_percentage:.2f}%', 
                ha='center',
                va='center',
                color='white',
                fontsize = font_size+2)
      
  ax.set_xlim(0.5, percentage_position+0.5)
  ax.set_xticks(range(1, int(percentage_position-1)))
  ax.set_ylabel('Traces',fontsize = font_size+3)
  ax.set_ylim(len(data_dict["Trace"]) + 0.45, 0.55) # y-axis is reversed
  ax.set_yticks([])
  ax.set_xlabel('Activities',fontsize = font_size+3)
  
  handles = [plt.Rectangle((0, 0), 0, 0, facecolor=color_dict[acr],
                            edgecolor='black', label=acronym[acr])
              for acr in acronym if acr in set(
                itertools.chain.from_iterable(data_dict['Trace']))]
  ax.legend(handles=handles, 
            bbox_to_anchor=[1.02, 1.02],
            loc='upper left',
            fontsize = font_size+6)
  for dir in ['left', 'right', 'top']:
      ax.spines[dir].set_visible(False)
  plt.tight_layout()
  plt.savefig(output_file)
  plt.close()


def trace_explorer(con,
                   cond,
                   top_k=5,
                   id_col='ID',
                   ev_col='Event',
                   date_col='date',
                   clust_col='cluster',
                   color_dict={}):
  '''Plot each clusters most frequent traces
    
    Args:
      con : db connector variable
      cond (str): predominal clinical condition's code
      top_k (int):  traces as keys and their statistics as values
      id_col (str): patients id column's name in evlog_file
      ev_col (str): events column's name in evlog_file
      date_col (str): events dates column's name in evlog_file
      clust_col (str): cluster column's name in evlog_file
      color_dict (dict): events as keys and colors as values  
  '''
  log_ = pm4py.format_dataframe(con.sql(f"SELECT * FROM eventlog_{cond}_clust_filtered").df(),
                                case_id=id_col,
                                activity_key=ev_col,
                                timestamp_key=date_col)                  
  log_ = log_.sort_values([id_col,date_col])
  log_ = log_[log_['cycle']=='start'] 
  for clust in set(log_[clust_col]):
      log = log_[log_[clust_col]==clust]
      len_id = len(set(log[id_col]))
      acronym = {t:t for t in sorted(set(log[ev_col]))}
      data_dict = make_data_dict(log,top_k,id_col)
      color_dict = update_color_dict(color_dict, data_dict)
      trace_plotter(data_dict,color_dict,acronym,
                    '../../outputs/t_cluster_%s_%i.png' % (cond,clust))
  return color_dict

```

To get the process maps of each cluster next R functions can be used:

```{r}
#| label: Process maps in R

load_log <- function(con,
                     query,case_id="ID",
                     activity_id="Event", 
                     lifecycle_id="cycle",
                     activity_instance_id="actins",
                     timestamp="date"){
  
  eventlog <- dbGetQuery(con,query)  
  eventlog = eventlog[order(eventlog$ID),]
  #To transform date to a format we can work with
  eventlog$date = as.POSIXct(eventlog$date, tz = "", format="%Y-%m-%d" ,
                                   tryFormats = c("%Y/%m/%d",
                                                  "%Y/%m/%d"),
                                   optional = FALSE) 
  
  
  
  evLog = eventlog %>%
    mutate(resource = NA) %>%
    mutate(cycle = fct_recode(cycle,
                              "start" = "start",
                              "complete" = "end")) %>%
    eventlog(
      case_id = case_id,
      activity_id = activity_id, 
      lifecycle_id = lifecycle_id, 
      activity_instance_id = activity_instance_id, 
      timestamp = timestamp, 
      resource_id = 'resource'
    )
  return(evLog)
}
make_process_map <- function(log,t_freq,output_file){
  log %>%
    filter_activity_frequency(percentage = 1) %>% # show only most frequent
    filter_trace_frequency(percentage = t_freq) %>%
    process_map(type_nodes = performance(mean,units='days'),
                type_edges = frequency('relative_case'),
                sec_edges = performance(mean,units='days'),
                render = T) %>% 
    export_svg %>% 
    charToRaw %>%
    rsvg_png (output_file,width=2000)
}

process_map_by_cluster <- function(evLog,t_freq,cond_code){
  for (clust in unique(evLog$cluster)) {
    log <- evLog %>% 
      filter(cluster == clust)
    make_process_map(log,t_freq,gsub("src/analysis-scripts/",
                                     "",here("outputs",sprintf(
                                       "pm_cluster_%s_%d.png", 
                                       cond_code, clust) )))

  }
}
```

### Conformance checking

Conformance checking is a technique used to check process compliance by comparing event logs for a discovered process with the existing reference model (target model) of the same process. Basing on the DM2 treatment algorithm previous shown, with a software called Carassius , we created the next Petri Nets that are going to be useful as treatment guidelines in reference to glycated hemoglobin measures.

![DM2 Treatment Algorithm's interpretation to patients with some CV disease in Petri Net format](../../outputs/PN_cvd.png){#fig-petrinet_cvd fig-align="center" width="100%"}

![DM2 Treatment Algorithm's interpretation to patients with heart failure in Petri Net format](../../outputs/PN_hf.png){#fig-petrinet_hf fig-align="center" width="100%\""}

![DM2 Treatment Algorithm's interpretation to patients with some chronic kidney disease in Petri Net format](../../outputs/PN_ckd.png){#fig-petrinet_ckd fig-align="center" width="100%"}

![DM2 Treatment Algorithm's interpretation to patients with frailty in Petri Net format](../../outputs/PN_f.png){#fig-petrinet_f fig-align="center" width="100%\""}

![DM2 Treatment Algorithm's interpretation to patients with obesity in Petri Net format](../../outputs/PN_ob.png){#fig-petrinet_ob fig-align="center" width="100%\""}

![DM2 Treatment Algorithm's interpretation to patients without predominant clinical condition in Petri Net format](../../outputs/PN_else.png){#fig-petrinet_else fig-align="center" width="100%\""}

Fitness is the metric that measures how much a trace is distanced from a given process model, or from the guidelines in this case. There are different methods to calculate this metric but in the code below is used the aligned fitness. Since in this metric the initial marking and the final marking have to be fixed we included the events 'INI' and 'FIN' in the Petri Net and in each trace. Adding this artificial events allows us to compare all traces fitness in the same conditions.

```{python}
#| label: Fitness  calculation (treatments)
def id2treat_fitness(log ,
               net, 
               initial_marking, 
               final_marking, 
               clust_col='cluster',
               date_col='date',
               ev_col='Event'):
  '''Obtain traces fitness
    
    Args:
      log (dataframe): event log 
      net: petri net
      initial_marking: initial place in the petri net
      final_marking: final place in the petri net
      clust_col (str): cluster column's name in log
      date_col (str): events dates column's name in log
      ev_col (str): events column's name in log
    Returns:
      df (dataframe): traces, their clusters and their fitnesses  
  '''
  id2trace = {id:list(log['Event'][log['case:concept:name']==id]
                      ) for id in set(log['case:concept:name'])}
  id2ids = {id:[id2 for id2 in set(id2trace.keys()) if id2trace[id]==id2trace[id2]
                ] for id in set(log['case:concept:name'])}
  for id in set(id2ids.keys()):
      try:
          for id2 in id2ids[id]:
              if id2!=id:
                  del id2ids[id2]
      except:
          continue
  
  id2fitness = dict()
  for name in set(id2ids.keys()):
      log2 = log.drop(log.index[log['case:concept:name'] !=name])
      new = log2.copy().iloc[[0, -1]]
      date_list = list(new[date_col])
      index = list(new['@@index'])
      actins = list(new['actins'])
      clust = new[clust_col].values[0]
      new[date_col] =  new['time:timestamp'] = [date_list[0]-timedelta(days=1),
                                                date_list[1]+timedelta(days=1)]
      new[ev_col] = new['concept:name'] = ['INI','FIN']
      new['@@index'] = [index[0]-1,index[1]+1]
      new['actins'] = [actins[0]-1,actins[1]+1]
    
      log2 = pd.concat([log2,new]).sort_values('time:timestamp')
      aligned_fitness = pm4py.conformance_diagnostics_alignments(
                        log2, net, initial_marking, final_marking)[0]['fitness']
      for id in id2ids[name]:
          id2fitness[id] = {'ID':id,
                            'aligned_fitness':aligned_fitness,
                            clust_col: clust}
  
  df = pd.DataFrame(id2fitness).T
  df.index = range(len(df))
  return df
```

The function below takes a treatments' event log and returns each patient's period's fitness.

```{python}
#| label: Fitness  calculation by intervals (treatments)
def id2treat_fitness_by_interval(con,
                           cond,
                           pn_file,
                           ini_place='place100',
                           fin_place='place111',
                           date_n_col='date',
                           fixed_period_time=90):
    '''Obtain traces fitness by intervals of fixed_period_time days
    
    Args:
      con: db connector variable
      cond (str): predominal clinical condition's code
      pn_file (str): petri net's path
      ini_place (str): initial place in the petri net
      fin_place (str): final place in the petri net
      date_n_col (str): events dates column's name in log
      fixed_period_time (int): number of days in each interval
  '''
    net, initial_marking, final_marking = pm4py.read_pnml(pn_file)
    initial_marking = Marking()
    initial_marking[list(net.places)[[str(p) for p in net.places].index(
        ini_place)]] = 1
    final_marking = Marking()
    final_marking[list(net.places)[[str(p) for p in net.places].index(
        fin_place)]] = 1
    event_log = pm4py.format_dataframe(con.sql(f"SELECT * FROM eventlog_{cond}_clust \
    WHERE cycle = 'start'").df(),
                                case_id='ID',
                                activity_key='Event',
                                timestamp_key=date_n_col) 
    event_log = event_log[event_log['cycle']=='start'] 
    baseline = datetime.strptime('2017-01-01', "%Y-%m-%d")
    endline = datetime.strptime('2023-01-01', "%Y-%m-%d")
    dd = [baseline + timedelta(days=x) for x in range((
              endline-baseline).days + 1)]
    dd_INI = dd[0]-timedelta(days=1)
    dd_FIN = dd[-1]+timedelta(days=1)
    event_log['time:timestamp'] = event_log['time:timestamp'].dt.tz_localize(None)
    event_log[date_n_col] = event_log[date_n_col].dt.tz_localize(None)
    event_log['date_'] = event_log[date_n_col].apply(
        lambda x: dd.index(x))
    event_log[date_n_col] = event_log[date_n_col].apply(
        lambda x: dd.index(x))
    event_log[date_n_col] = event_log.groupby('ID')[date_n_col].apply(
        lambda x: x-x.min())
    
    hosp = con.sql("SELECT * FROM cmbd_incidents_postdx_first_view").df()
    hosp['admission_date'] = hosp['admission_date'].dt.tz_localize(None).apply(
        lambda x: dd.index(x))
    hosp = dict(zip(hosp.patient_id,hosp.admission_date))
    
    period2fitness = pd.DataFrame()
    id_list_df = []
    p_start = []
    p_end = []
    fitness = []
    date_0 = []
    status = []
    id_list = list(set(event_log['ID']))
    for id in tqdm(id_list):
        event_log_id = event_log[event_log['ID']==id]
        hosp_d = hosp.get(id,100000)-min(event_log_id['date_'])
        date_max = min(max(event_log_id[date_n_col]),hosp_d)
        date_min = min(event_log_id['time:timestamp'])
        n_periods = date_max//fixed_period_time
        n_periods_r = date_max/fixed_period_time
        if date_max<=fixed_period_time:
            continue
        for n in range(1,n_periods+1):
            event_log_id_n = event_log_id[
                event_log_id[date_n_col]<n*fixed_period_time]
            
            new = event_log_id.copy().iloc[[0, -1]]
            actins = list(new['actins'])
            index = list(new['@@index'])
            new['time:timestamp'] = [dd_INI,dd_FIN]
            new['concept:name'] = ['INI','FIN']
            new['@@index'] = [index[0]-1,index[1]+1]
            new['actins'] = [actins[0]-1,actins[1]+1]
            event_log_id_n = pd.concat([event_log_id_n,new]
                                       ).sort_values('time:timestamp')
            aligned_fitness = pm4py.conformance_diagnostics_alignments(
                             event_log_id_n, net, 
                             initial_marking, final_marking)[0]['fitness']
            id_list_df.append(id)
            p_start.append((n-1)*fixed_period_time)
            p_end_value = n*fixed_period_time
            if n==n_periods:
                p_end_value = date_max-fixed_period_time
            p_end.append(p_end_value)
            fitness.append(aligned_fitness)
            date_0.append(date_min)
            if (n==n_periods or n==n_periods_r-1) and hosp_d==date_max :
                status.append(1)
                break
            else:
                status.append(0)
    
    period2fitness['ID'] = id_list_df
    period2fitness['t_0'] = p_start
    period2fitness['t_1'] = p_end
    period2fitness['fitness'] = fitness
    period2fitness['ini_date'] = date_0
    period2fitness['status'] = status
    con.sql(f"DROP TABLE IF EXISTS period2fitness_{cond}")
    con.sql(f"CREATE TABLE period2fitness_{cond} AS SELECT *,\
            MAX(status) OVER (PARTITION BY ID) AS status2  FROM period2fitness \
            WHERE t_0!=t_1") 
```

In the next function is shown a boxplot function to show clusters' fitness distribution.

```{python}
#| label: Fitness boxplot
def treatments_clusters_boxplot(con,
                cond,
                pn_file,
                pn_png_file,
                ini_place='place100',
                fin_place='place111',
                date_col='date',
                ev_col='Event',
                clust_col='cluster',
                output_png='../../outputs/fitness_by_cluster.png'):
  '''Barplot of the fitness of each cluster
    
    Args:
      con: db connector variable
      cond (str): predominant clinical condition
      pn_file: petri net's path
      ini_marking: initial place in the petri net
      fin_marking: final place in the petri net
      date_col (str): events dates column's name in log
      clust_col (str): cluster column's name in log
      ev_col (str): events column's name in log
      output_png (str): created figure's path
  '''
  log = pm4py.format_dataframe(con.sql(f"SELECT * FROM eventlog_{cond}_clust_filtered \
  WHERE cycle = 'start'").df(),
                                case_id='ID',
                                activity_key=ev_col,
                                timestamp_key=date_col)                  

  log = log.sort_values(date_col)
  log.index = range(len(log))
  net, initial_marking, final_marking = pm4py.read_pnml(pn_file)
  initial_marking = Marking()
  initial_marking[list(net.places)[[str(p) for p in net.places].index(
    ini_place)]] = 1
  final_marking = Marking()
  final_marking[list(net.places)[[str(p) for p in net.places].index(
    fin_place)]] = 1
  pm4py.save_vis_petri_net(net, initial_marking, final_marking,pn_png_file)
  df = id2treat_fitness(log,net,initial_marking,final_marking,
                  clust_col,date_col,ev_col)
  df['aligned_fitness'] = pd.to_numeric(df['aligned_fitness'])
  df['cluster'] = pd.to_numeric(df['cluster'])
  df['ID'] = df['ID'].astype("string")
  con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}_byclust")                
  con.sql(f"CREATE TABLE eventlog_{cond}_byclust AS \
  SELECT * FROM df")
  data = [list(df['aligned_fitness'][df[clust_col]==i])
          for i in sorted(set(df[clust_col]))]
   
  fig = plt.figure(figsize =(10, 7))
  # Creating axes instance
  ax = fig.add_axes([0, 0, 1, 1])
  # Creating plot
  bp = ax.boxplot(data,labels=[i for i in sorted(set(df[clust_col]))])
  plt.xlabel("Clusters")
  plt.ylabel("Aligned Fitness")
  # show plot
  plt.savefig(output_png,bbox_inches='tight')
  plt.close(fig)
  

```

Process indicators can also be represented in a Petri Net. Therefore we created the next Petri Nets to analyze whether the traces obey the guidelines the first five years:

![Petri Net of process indicators of the first year](../../outputs/PN_process1.png){#fig-petrinet_process1 fig-align="center" width="100%"}

![Petri Net of process indicators of the first two years](../../outputs/PN_process2.png){#fig-petrinet_process2 fig-align="center" width="100%"}

![Petri Net of process indicators of the first three years](../../outputs/PN_process3.png){#fig-petrinet_process3 fig-align="center" width="100%"}

![Petri Net of process indicators of the first four years](../../outputs/PN_process4.png){#fig-petrinet_process4 fig-align="center" width="100%"}

![Petri Net of process indicators of the first five years](../../outputs/PN_process5.png){#fig-petrinet_process5 fig-align="center" width="100%"}

The function below takes a process indicators' event log and returns each patient's fitness by year. The method to calculate the fitness in this case is the token base replay method.

```{python}
#| label: Fitness  calculation (process_indicators)
def id2process_fitness(con,
                       query,
                       pn_file,
                       pn_png_file,
                       ini_place='place37',
                       fin_place='place148',
                       id_col = 'patient_id',
                       event_col = 'event',
                       date_col='date',):
    '''Calculate the fitness of a given process indicators' event log
    
    Args:
      con: db connector variable
      cond (str): predominal clinical condition's code
      query (str): query to select event log
      pn_file (str): petri net's path
      ini_place (str): initial place in the petri net
      fin_place (str): final place in the petri net
      id_col (str): ids' column's name in event log
      event_col (str): events' column's name in event log
      date_col (str): events' dates' column's name in event log
    Returns:
      df (dataframe): dataframe of ids' fitness
  '''
    net, initial_marking, final_marking = pm4py.read_pnml(pn_file)
    initial_marking = Marking()
    initial_marking[list(net.places)[[str(p) for p in net.places].index(
        ini_place)]] = 1
    final_marking = Marking()
    final_marking[list(net.places)[[str(p) for p in net.places].index(
        fin_place)]] = 1
    pm4py.save_vis_petri_net(net, initial_marking, final_marking,pn_png_file)
    event_log = pm4py.format_dataframe(con.sql(query).df(),
                                case_id=id_col,
                                activity_key=event_col,
                                timestamp_key=date_col) 
    date_list = []
    fit_list = []
    id_list = list(set(event_log[id_col]))
    for id in tqdm(id_list):
        log = event_log.drop(event_log.index[event_log['case:concept:name'] !=id]
                              ).sort_values('time:timestamp')
        fit_obj = pm4py.conformance.conformance_diagnostics_token_based_replay(
            log, net, initial_marking, final_marking)
        date_list.append(list(log['time:timestamp'])[-2])
        fit_list.append(fit_obj[0]['trace_fitness'])
        
    log_0 = log[log['concept:name'].isin(['INI','FIN','yFIN'])]
    alfa = pm4py.conformance.conformance_diagnostics_token_based_replay(
        log_0, net, initial_marking, final_marking)[0]['trace_fitness']
    
    df =  pd.DataFrame()
    df['ID'] = id_list
    df['fitness'] = [(x-alfa)/(1-alfa) for x in fit_list]
    df['date'] = date_list
    return df
```

### Decision mining

Decision mining allows to analyze the event transitions in different part of processes. With another words, we can measure patients' characteristics or their relevance in a specific place of the passed petri net. The next function makes a decision tree explaining how patients characteristics are taking into account. Moreover it shows a boxplot of the relevance of each feature in the decision tree obtained with mean decrease impurity which calculates each feature importance as the sum over the number of splits (across all tress) that include the feature, proportionally to the number of samples it splits.

```{python}
#| label: Decision mining
def decision_tree_pn_place(con,
                           cond,
                           features_list = ['age','sex','copayment'],
                           pn_file="./PN.pnml",
                           place2analyze='place9',
                           ini_place='place100',
                           fin_place='place111'):
  '''Decision tree and features importances in selected place of PN
    
    Args:
      con : db connector variable
      cond (str): predominant clinical condition's 
      features_list (list): features wanted to analyze
      event_log_file (str): event log's path
      pn_file (str): petri net's path
      place2analyze (str): place wanted to analyze in petri net
      ini_place (str): initial place in the petri net
      fin_place (str): final place in the petri net
      
  '''                           
  log = pm4py.format_dataframe(con.sql(f"SELECT * FROM eventlog_{cond} WHERE \
  ID in (SELECT ID FROM eventlog_{cond}_clust)").df(), case_id='ID',
                               activity_key='Event',timestamp_key='date')  
  log = log[log['cycle']=='start']    
  log = log[['concept:name','time:timestamp','case:concept:name']]
  ini = min(list(log['time:timestamp']))-timedelta(days=1)
  fin = max(list(log['time:timestamp']))+timedelta(days=1)
  patients = list(set(log['case:concept:name']))
  add_ini_fin = {'case:concept:name' : patients*2,
                   'time:timestamp':[ini]*len(patients)+[fin]*len(patients),
                   'concept:name':['INI']*len(patients)+['FIN']*len(patients)}
  log = pd.concat([log,pd.DataFrame(add_ini_fin)])
        
  log = log.sort_values(['case:concept:name','time:timestamp'])
  log.index = range(len(log))
  patients_df = con.sql("SELECT patient_id,age,sex,copayment FROM patient_incidents_view").df()
  patients_df = patients_df.fillna(2)
  patients_df['copayment'] = patients_df['copayment'].values.astype(int).astype(str)
  log_patients = log.merge(patients_df,left_on='case:concept:name',
                             right_on='patient_id',how='left')
  log_patients = log_patients[['concept:name', 'time:timestamp',
                                 'case:concept:name', 'age',
                                 'sex','copayment']]
  net, initial_marking, final_marking = pm4py.read_pnml(pn_file)
    
  initial_marking = Marking()
  initial_marking[list(net.places)[[str(p) 
                    for p in net.places].index(ini_place)]] = 1
  final_marking = Marking()
  final_marking[list(net.places)[[str(p) 
                  for p in net.places].index(fin_place)]] = 1
  try:
    X, y, class_names = decision_mining.apply(log_patients,
                                              net,
                                              initial_marking,
                                              final_marking,
                                              decision_point=place2analyze)
    clf, feature_names, classes = decision_mining.get_decision_tree(log_patients,
                                                    net,
                                                    initial_marking,
                                                    final_marking, 
                                                    decision_point=place2analyze)
    gviz = tree_visualizer.apply(clf, feature_names, classes)
    gviz.save(filename='decision_tree_%s' % cond,
                directory='../../outputs')              
    visualizer.view(gviz)
      
    importances = clf.feature_importances_
    tree_importances = pd.Series(importances, index=feature_names)
    
    fig, ax = plt.subplots()
    tree_importances.plot.bar(ax=ax)
    ax.set_title("Feature importances using MDI")
    ax.set_ylabel("Mean decrease in impurity")
    fig.tight_layout()
    fig.savefig('../../outputs/barplot_features_importance_%s.png' % cond)
    plt.close(fig)
  except ValueError as err:
    logging.basicConfig(level=logging.INFO)
    logging.info('Error in decidsion making: %s', str(err))
    if str(err)!='No objects to concatenate':
      UNKNOWN_ERROR
```

### Time dependent Cox model

The link between guideline adherence, in terms of performed process measures, and clinical outcomes is a highly demanded issue in diabetes care. A Cox model is a statistical technique for exploring the relationship between the survival of a patient and several explanatory variables. One of the strengths of the Cox model is its ability to encompass covariates that change over time, such as treatment adherence. A time dependent Cox model can be made using each patient trace’s fitness at different time interval. 

### Joint Latent Class Model

Joint models are used to analyse simultaneously two related phenomena, the evolution of a variable and the occurence of an event. Joint latent class models (JLCM) consist of a linear mixed model and a proportional hazard model linked by the latent classes. The population is split in several groups, the latent classes, and each class is caracterized by a specific evolution of the dependent variable and an associated risk of event. Using fitness as time dependent treatment adherence measure we can made a joint latent class model.

## Results

### Cohort description

```{python}
#| label: preprocessing of the initial dataframes
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info('Preprocess of the initial dataframes')
#db_path = '../../inputs/data.duckdb'
db_path = 'C:/Users/D463112/Desktop/ejemplo_cdmb/inputs/data.duckdb'
con = duckdb.connect(db_path)
general_preprocess(con)
notnan_p = separate_patients_by_condition(con)
con.close()
```

```{r}
#| label: fixing db pathway
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
#db_path <- '../../inputs/data.duckdb'
db_path <- 'C:/Users/D463112/Desktop/ejemplo_cdmb/inputs/data.duckdb'
con <- dbConnect(duckdb(), dbdir = db_path)
country2cont = read.csv('./country2continent.csv') %>% 
  transform(country = as.numeric(country))
```

```{r}
#| label: tbl-patient_inc
#| tbl-cap: "Demographic and socioeconomic characteristics of incidents patients "
#| tbl-colwidths: [60,40]

###INCIDENTS
patient_inc <- dbGetQuery(con,
                       "SELECT *,
                       CASE WHEN sex = 0 THEN 'Male' 
                       ELSE 'Female' END AS sexo FROM patient_incidents_view") 
patient_inc <- patient_inc %>%
  left_join( country2cont %>% select(country, CC), by = "country") %>%
  mutate(education=factor(education, levels=c(0,1,2,3),
      labels=c("Without studies","Primary school",
               "High school","University")),
      copayment=factor(copayment,levels=c(0,1),
                       labels=c("less than 18000","more or equal than 18000")))
patient_inc$CC[patient_inc$country == 724] <- 'Spain'
dependent="sexo"
explanatory=c("age","age_dx","CC","copayment","education", "avg_income")  

patient_inc%>%summary_factorlist(dependent,
                              explanatory,
                              total_col = TRUE,
                              cont="mean",
                              cont_cut=7,
                              na_include = TRUE,
                              na_to_prop =  FALSE, 
                              include_col_totals_percent	=FALSE,
                              add_col_totals = TRUE)-> patient_inc_tab

kable(patient_inc_tab, row.names=FALSE, align=c("l", "l", rep("r",5)))

```

```{r}
#| label: tbl-param_inc
#| tbl-cap: "Demographic and socioeconomic characteristics of incidents patients "
#| tbl-colwidths: [60,40]
param_inc <- dbGetQuery(con,"SELECT * FROM param_incidents_predx_last_view")
param_cat_inc <- dbGetQuery(con,"SELECT * FROM param_cat_incidents_predx_last_view")
dependent="sexo"


param_inc2unnest <- param_inc %>% 
  pivot_wider( id_cols=patient_id,names_from=param_name,values_from=param_value)%>%
  left_join( patient_inc %>% select(patient_id, sexo), by = "patient_id")

param_cat_inc$param_cat_value = as.numeric(as.character(param_cat_inc$param_cat_value))
param_cat_inc2unnest <- param_cat_inc %>% 
  pivot_wider( id_cols=patient_id,names_from=param_cat_name,values_from=param_cat_value)%>%
  left_join( patient_inc %>% select(patient_id, sexo), by = "patient_id") %>%
  mutate(physical_activity=factor(physical_activity, levels=c(0,1,2,3),
                                  labels=c("Incapacity", "Inactive", "Partially Active","Active")),
         smoking_status=factor(smoking_status, levels=c(0,1,2,3),
                               labels=c("Non Smoker", "Ex-smoker < 1 year", "Ex-smoker >= 1 year","Smoker")),
         alcohol=factor(alcohol, levels=c(0,1,2),
                        labels=c("Abstinent", "Moderate Drinker","Heavy Drinker")),
         vaccination_covid=factor(vaccination_covid, levels=c(0,1,2,3,4,5,6,7),
                                  labels=c("No", "Yes, BioNTech-Pfizer","Yes, Moderna","Yes, Astrazeneca","Yes, Johnson-Johnson","Yes, Novavax","Yes, Other","Yes, Unknown type")),
         vaccination_flu=factor(vaccination_flu, levels=c(0,1), labels=c("No", "Yes")),
         working_status=factor(working_status,levels=c(0,1,2),labels=c('Active','Unemployed','Pensionist')))

param_inc_tab <- rbind(
  param_inc2unnest %>%
    summary_factorlist(dependent ,
                       c("bmi","height","weight","sbp","dbp","hba1c","col",
                         "hdl","ldl","trgl","creat","indalbcr","alb"),
                       total_col = TRUE,cont="mean",na_include = TRUE,
                       na_to_prop =  FALSE,add_row_totals = TRUE,
                       include_row_missing_col = TRUE,
                       include_col_totals_percent	=FALSE,add_col_totals = TRUE),
  param_cat_inc2unnest %>%
    summary_factorlist(dependent ,
                       c("physical_activity","smoking_status","alcohol","vaccination_flu",'working_status'),
                       total_col = TRUE,cont="mean",na_include = TRUE,
                       na_to_prop =  FALSE,cont_cut=8,add_row_totals = TRUE,
                       include_row_missing_col = TRUE))
kable(param_inc_tab, row.names=FALSE, align=c("l", "l", rep("r",5)))
```

```{r}
#| label: tbl-use_inc
#| tbl-cap: "Use of Primary Care Services per year of incidents patients"
#| tbl-colwidths: [60,40]

patient_inc$deregistration_date <- patient_inc$deregistration_date %>%
  replace_na(as.Date('2023-01-01'))
patient_inc <- patient_inc %>% 
  mutate(follow_up_time=as.numeric(difftime(deregistration_date,
                                            dx_date,units="days")/365.25)) %>%
  filter(follow_up_time!=0)

ss_use_inc <- dbGetQuery(con," SELECT * FROM main.ss_use \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date >='2017-01-01') AND \
                  visit_date>= (SELECT dx_date FROM main.patient WHERE \
                  main.patient.patient_id = main.ss_use.patient_id)") %>% mutate(
                        visit_type=factor(visit_type, levels=c(1,2,3,4,5,6,7,8),
                        labels=c("PC_physician", "PC_nurse", "PC_social_worker",
                                 "PC_emergency_service","PC_others",
                                 "Specialized_visit_physician",
                                 "Specialized_visit_nurse",
                                 "Specialized_visit_unknown_professional")))

ss_use_inc1 <- ss_use_inc %>% 
  filter(visit_loc == 1)
use_inc_freq1 <- as.data.frame.matrix(table(ss_use_inc1$patient_id,ss_use_inc1$visit_type))
use_inc_freq1 <- cbind(patient_id = rownames(use_inc_freq1), use_inc_freq1)
use_inc_freq1_time <- left_join(use_inc_freq1, patient_inc %>% select(patient_id, sex, follow_up_time,dx_date), by = "patient_id") %>%
  mutate(PC_physician= PC_physician/follow_up_time,
         PC_nurse=PC_nurse/follow_up_time,
         PC_social_worker=PC_social_worker/follow_up_time,
         PC_emergency_service=PC_emergency_service/follow_up_time,
         PC_others=PC_others/follow_up_time,
         Specialized_visit_physician=Specialized_visit_physician/follow_up_time,
         Specialized_visit_nurse=Specialized_visit_nurse/follow_up_time,
         Specialized_visit_unknown_professional=Specialized_visit_unknown_professional/follow_up_time,
         sexo=factor(sex, levels=c(0,1), labels=c("Male", "Female"))) 

ss_use_inc2 <- ss_use_inc %>% 
  filter(visit_loc == 2)
use_inc_freq2 <- as.data.frame.matrix(table(ss_use_inc2$patient_id,ss_use_inc2$visit_type))
use_inc_freq2 <- cbind(patient_id = rownames(use_inc_freq2), use_inc_freq2)
use_inc_freq2_time <- left_join(use_inc_freq2, patient_inc %>% select(patient_id, sex, follow_up_time,dx_date), by = "patient_id") %>%
  mutate(PC_physician= PC_physician/follow_up_time,
         PC_nurse=PC_nurse/follow_up_time,
         PC_social_worker=PC_social_worker/follow_up_time,
         PC_emergency_service=PC_emergency_service/follow_up_time,
         PC_others=PC_others/follow_up_time,
         Specialized_visit_physician=Specialized_visit_physician/follow_up_time,
         Specialized_visit_nurse=Specialized_visit_nurse/follow_up_time,
         Specialized_visit_unknown_professional=Specialized_visit_unknown_professional/follow_up_time,
         sexo=factor(sex, levels=c(0,1), labels=c("Male", "Female"))) 

ss_use_inc3 <- ss_use_inc %>% 
  filter(visit_loc == 3)
use_inc_freq3 <- as.data.frame.matrix(table(ss_use_inc3$patient_id,ss_use_inc3$visit_type))
use_inc_freq3 <- cbind(patient_id = rownames(use_inc_freq3), use_inc_freq3)
use_inc_freq3_time <- left_join(use_inc_freq3, patient_inc %>% select(patient_id, sex, follow_up_time,dx_date), by = "patient_id") %>%
  mutate(PC_physician= PC_physician/follow_up_time,
         PC_nurse=PC_nurse/follow_up_time,
         PC_social_worker=PC_social_worker/follow_up_time,
         PC_emergency_service=PC_emergency_service/follow_up_time,
         PC_others=PC_others/follow_up_time,
         Specialized_visit_physician=Specialized_visit_physician/follow_up_time,
         Specialized_visit_nurse=Specialized_visit_nurse/follow_up_time,
         Specialized_visit_unknown_professional=Specialized_visit_unknown_professional/follow_up_time,
         sexo=factor(sex, levels=c(0,1), labels=c("Male", "Female"))) 


use_inc_tab <- rbind(
  rbind(data.frame(label = "at care center", levels = '',
                   Male = '', Female = '', Total = ''),
        use_inc_freq1_time %>%
          summary_factorlist(dependent ,c("PC_physician", "PC_nurse", "PC_social_worker",
                                          "PC_emergency_service","PC_others",
                                          "Specialized_visit_physician",
                                          "Specialized_visit_nurse",
                                          "Specialized_visit_unknown_professional"),
                             total_col = TRUE,cont="mean",cont_cut=1,
                             na_include = TRUE,na_to_prop =  FALSE)),
  rbind(data.frame(label = "at home", levels = '',
                   Male = '', Female = '', Total = ''),
        use_inc_freq2_time %>%
          summary_factorlist(dependent ,c("PC_physician", "PC_nurse", "PC_social_worker",
                                          "PC_emergency_service","PC_others",
                                          "Specialized_visit_physician",
                                          "Specialized_visit_nurse",
                                          "Specialized_visit_unknown_professional"),
                             total_col = TRUE,cont="mean",cont_cut=1,
                             na_include = TRUE,na_to_prop =  FALSE)),
  rbind(data.frame(label = "by telephone or similar", levels = '',
                   Male = '', Female = '', Total = ''),
        use_inc_freq3_time %>%
          summary_factorlist(dependent ,c("PC_physician", "PC_nurse", "PC_social_worker",
                                          "PC_emergency_service","PC_others",
                                          "Specialized_visit_physician",
                                          "Specialized_visit_nurse",
                                          "Specialized_visit_unknown_professional"),
                             total_col = TRUE,cont="mean",cont_cut=1,
                             na_include = TRUE,na_to_prop =  FALSE)))

kable(use_inc_tab, row.names=FALSE, align=c("l", "l", rep("r",5)))

```

```{r}
#| label: tbl-patient_pre
#| tbl-cap: "Demographic and socioeconomic characteristics of prevalents patients"
#| tbl-colwidths: [60,40]
patient_pre <- dbGetQuery(con,
                          "SELECT *,
                       CASE WHEN sex = 0 THEN 'Male' 
                       ELSE 'Female' END AS sexo,
                       FLOOR(DATEDIFF('day',month_nac,DATE '2017-01-01') / 365.25) 
                       AS 'age',
                       FLOOR(DATEDIFF('day',month_nac, dx_date) / 365.25) 
                       AS 'age_dx'FROM main.patient 
                       WHERE dx_date < '2017-01-01'") 
patient_pre <- patient_pre %>%
  left_join( country2cont %>% select(country, CC), by = "country") %>%
  mutate(education=factor(education, levels=c(0,1,2,3),
      labels=c("Without studies","Primary school",
               "High school","University")),
      copayment=factor(copayment,levels=c(0,1),
                       labels=c("less than 18000","more or equal than 18000")))
patient_pre$CC[patient_pre$country == 724] <- 'Spain'
dependent="sexo"
explanatory=c("age","age_dx","CC","copayment","education", "avg_income")  

patient_pre%>%summary_factorlist(dependent,
                                 explanatory,
                                 total_col = TRUE,
                                 cont="mean",
                                 cont_cut=7,
                                 na_include = TRUE,
                                 na_to_prop =  FALSE, 
                                 include_col_totals_percent	=FALSE,
                                 add_col_totals = TRUE)-> patient_pre_tab
kable(patient_pre_tab, row.names=FALSE, align=c("l", "l", rep("r",5)))

```

```{r}
#| label: tbl-param_pre
#| tbl-cap: "Clinical and lifestyle characteristics of prevalent patients"
#| tbl-colwidths: [60,40]
param_pre <- dbGetQuery(con,"SELECT * FROM param_prevalents_pre_last_view")
param_cat_pre <- dbGetQuery(con,"SELECT * FROM param_cat_prevalents_pre_last_view")
dependent="sexo"


param_pre2unnest <- param_pre %>% 
  pivot_wider( id_cols=patient_id,names_from=param_name,values_from=param_value)%>%
  left_join( patient_pre %>% select(patient_id, sexo), by = "patient_id")

param_cat_pre$param_cat_value = as.numeric(as.character(param_cat_pre$param_cat_value))
param_cat_pre2unnest <- param_cat_pre %>% 
  pivot_wider( id_cols=patient_id,names_from=param_cat_name,values_from=param_cat_value)%>%
  left_join( patient_pre %>% select(patient_id, sexo), by = "patient_id") %>%
  mutate(physical_activity=factor(physical_activity, levels=c(0,1,2,3),
                                  labels=c("Incapacity", "Inactive", "Partially Active","Active")),
         smoking_status=factor(smoking_status, levels=c(0,1,2,3),
                               labels=c("Non Smoker", "Ex-smoker < 1 year", "Ex-smoker >= 1 year","Smoker")),
         alcohol=factor(alcohol, levels=c(0,1,2),
                        labels=c("Abstinent", "Moderate Drinker","Heavy Drinker")),
         vaccination_covid=factor(vaccination_covid, levels=c(0,1,2,3,4,5,6,7),
                                  labels=c("No", "Yes, BioNTech-Pfizer","Yes, Moderna","Yes, Astrazeneca","Yes, Johnson-Johnson","Yes, Novavax","Yes, Other","Yes, Unknown type")),
         vaccination_flu=factor(vaccination_flu, levels=c(0,1), labels=c("No", "Yes")),
         working_status=factor(working_status,levels=c(0,1,2),labels=c('Active','Unemployed','Pensionist')))

param_pre_tab <- rbind(
  param_pre2unnest %>%
    summary_factorlist(dependent ,
                       c("bmi","height","weight","sbp","dbp","hba1c","col",
                         "hdl","ldl","trgl","creat","indalbcr","alb"),
                       total_col = TRUE,cont="mean",na_include = TRUE,
                       na_to_prop =  FALSE,add_row_totals = TRUE,
                       include_row_missing_col = TRUE,
                       include_col_totals_percent	=FALSE,add_col_totals = TRUE),
  param_cat_pre2unnest %>%
    summary_factorlist(dependent ,
                       c("physical_activity","smoking_status","alcohol","vaccination_flu",'working_status'),
                       total_col = TRUE,cont="mean",na_include = TRUE,
                       na_to_prop =  FALSE,cont_cut=8,add_row_totals = TRUE,
                       include_row_missing_col = TRUE))
kable(param_pre_tab, row.names=FALSE, align=c("l", "l", rep("r",5)))

```

```{r}
#| label: tbl-use_pre
#| tbl-cap: "Use of Primary Care Services of prevalent patients"
#| tbl-colwidths: [60,40]
patient_pre$deregistration_date <- patient_pre$deregistration_date %>%
  replace_na(as.Date('2023-01-01'))
patient_pre <- patient_pre %>% 
  mutate(follow_up_time=as.numeric(difftime(deregistration_date,                                          as.Date('2016-12-31'),units="days")/365.25))%>%
  filter(follow_up_time!=0)



ss_use_pre <- dbGetQuery(con," SELECT * FROM main.ss_use \
            WHERE patient_id IN (SELECT patient_id FROM main.patient \
                                 WHERE dx_date <'2017-01-01') AND
                         visit_date>='2017-01-01'") %>% mutate(
                           visit_type=factor(visit_type, levels=c(1,2,3,4,5,6,7,8),
                          labels=c("PC_physician", "PC_nurse", "PC_social_worker",
                                   "PC_emergency_service","PC_others",
                                   "Specialized_visit_physician",
                                   "Specialized_visit_nurse",
                                   "Specialized_visit_unknown_professional"))
                         )

ss_use_pre1 <- ss_use_pre %>% 
  filter(visit_loc == 1)
use_pre_freq1 <- as.data.frame.matrix(table(ss_use_pre1$patient_id,ss_use_pre1$visit_type))
use_pre_freq1 <- cbind(patient_id = rownames(use_pre_freq1), use_pre_freq1)
use_pre_freq1_time <- left_join(use_pre_freq1, patient_pre %>% select(patient_id, sex, follow_up_time,dx_date), by = "patient_id") %>%
  mutate(PC_physician= PC_physician/follow_up_time,
         PC_nurse=PC_nurse/follow_up_time,
         PC_social_worker=PC_social_worker/follow_up_time,
         PC_emergency_service=PC_emergency_service/follow_up_time,
         PC_others=PC_others/follow_up_time,
         Specialized_visit_physician=Specialized_visit_physician/follow_up_time,
         Specialized_visit_nurse=Specialized_visit_nurse/follow_up_time,
         Specialized_visit_unknown_professional=Specialized_visit_unknown_professional/follow_up_time,
         sexo=factor(sex, levels=c(0,1), labels=c("Male", "Female"))) 

ss_use_pre2 <- ss_use_pre %>% 
  filter(visit_loc == 2)
use_pre_freq2 <- as.data.frame.matrix(table(ss_use_pre2$patient_id,ss_use_pre2$visit_type))
use_pre_freq2 <- cbind(patient_id = rownames(use_pre_freq2), use_pre_freq2)
use_pre_freq2_time <- left_join(use_pre_freq2, patient_pre %>% select(patient_id, sex, follow_up_time,dx_date), by = "patient_id") %>%
  mutate(PC_physician= PC_physician/follow_up_time,
         PC_nurse=PC_nurse/follow_up_time,
         PC_social_worker=PC_social_worker/follow_up_time,
         PC_emergency_service=PC_emergency_service/follow_up_time,
         PC_others=PC_others/follow_up_time,
         Specialized_visit_physician=Specialized_visit_physician/follow_up_time,
         Specialized_visit_nurse=Specialized_visit_nurse/follow_up_time,
         Specialized_visit_unknown_professional=Specialized_visit_unknown_professional/follow_up_time,
         sexo=factor(sex, levels=c(0,1), labels=c("Male", "Female"))) 

ss_use_pre3 <- ss_use_pre %>% 
  filter(visit_loc == 3)
use_pre_freq3 <- as.data.frame.matrix(table(ss_use_pre3$patient_id,ss_use_pre3$visit_type))
use_pre_freq3 <- cbind(patient_id = rownames(use_pre_freq3), use_pre_freq3)
use_pre_freq3_time <- left_join(use_pre_freq3, patient_pre %>% select(patient_id, sex, follow_up_time,dx_date), by = "patient_id") %>%
  mutate(PC_physician= PC_physician/follow_up_time,
         PC_nurse=PC_nurse/follow_up_time,
         PC_social_worker=PC_social_worker/follow_up_time,
         PC_emergency_service=PC_emergency_service/follow_up_time,
         PC_others=PC_others/follow_up_time,
         Specialized_visit_physician=Specialized_visit_physician/follow_up_time,
         Specialized_visit_nurse=Specialized_visit_nurse/follow_up_time,
         Specialized_visit_unknown_professional=Specialized_visit_unknown_professional/follow_up_time,
         sexo=factor(sex, levels=c(0,1), labels=c("Male", "Female"))) 


use_pre_tab <- rbind(
  rbind(data.frame(label = "at care center", levels = '',
                   Male = '', Female = '', Total = ''),
        use_pre_freq1_time %>%
    summary_factorlist(dependent ,c("PC_physician", "PC_nurse", "PC_social_worker",
                                    "PC_emergency_service","PC_others",
                                    "Specialized_visit_physician",
                                    "Specialized_visit_nurse",
                                    "Specialized_visit_unknown_professional"),
                       total_col = TRUE,cont="mean",cont_cut=1,
                       na_include = TRUE,na_to_prop =  FALSE)),
    rbind(data.frame(label = "at home", levels = '',
                     Male = '', Female = '', Total = ''),
        use_pre_freq2_time %>%
    summary_factorlist(dependent ,c("PC_physician", "PC_nurse", "PC_social_worker",
                                    "PC_emergency_service","PC_others",
                                    "Specialized_visit_physician",
                                    "Specialized_visit_nurse",
                                    "Specialized_visit_unknown_professional"),
                        total_col = TRUE,cont="mean",cont_cut=1,
                        na_include = TRUE,na_to_prop =  FALSE)),
    rbind(data.frame(label = "by telephone or similar", levels = '',
                     Male = '', Female = '', Total = ''),
        use_pre_freq3_time %>%
    summary_factorlist(dependent ,c("PC_physician", "PC_nurse", "PC_social_worker",
                                    "PC_emergency_service","PC_others",
                                    "Specialized_visit_physician",
                                    "Specialized_visit_nurse",
                                    "Specialized_visit_unknown_professional"),
                        total_col = TRUE,cont="mean",cont_cut=1,
                        na_include = TRUE,na_to_prop =  FALSE)))

kable(use_pre_tab, row.names=FALSE, align=c("l", "l", rep("r",5)))
```

```{r}
#| label: db shutdown
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
dbDisconnect(con, shutdown = TRUE)
rm(param_cat_inc,param_cat_inc2unnest,param_cat_pre,param_cat_pre2unnest,param_inc,param_inc_tab,param_inc2unnest,param_pre,param_pre_tab,param_pre2unnest,patient_inc,patient_inc_tab,patient_pre,patient_pre_tab,ss_use_inc,ss_use_inc1,ss_use_inc2,ss_use_inc3,ss_use_pre,ss_use_pre1,ss_use_pre2,ss_use_pre3,use_inc_freq1,use_inc_freq1_time,use_inc_freq2,use_inc_freq2_time,use_inc_freq3,use_inc_freq3_time,use_inc_tab,use_pre_freq1,use_pre_freq1_time,use_pre_freq2,use_pre_freq2_time,use_pre_freq3,use_pre_freq3_time,use_pre_tab)
```

### Patients without predominant clinical condition

#### Event log's creation and description

```{python}
#| label: condition variable in python (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond = 'else'
```

```{r}
#| label: condition variable in r (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond <- 'else'
```

```{python}
#| label: Preprocessing of raw event log (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con = duckdb.connect(db_path)
if notnan_p>0.98:
  logging.info("Generate event log of %s patients from prescriptions", cond)
  evlog_creation_by_prescriptions(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv')
else:
  logging.info("Generate event log of %s patients from dispensations", cond)
  evlog_creation_by_dispensations(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv',
    nac_path='./Nomenclator_de_Facturacion.csv')
```

```{python}
#| label: event log (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Filter event log of %s patients", cond)
df_ = con.sql(f"SELECT * FROM evlog_raw_{cond}").df()

def df2dict(df_):
  '''Filtering length=2 traces and obtain id2trace dict
    
    Args:
      df_ (dataframe): event log 
    Returns:
      df (dataframe): filtered event log (without cycle sense)
      df_ (dataframe): filtered event log
      id2trace_ (dict): patients' ids as keys and their traces (list) as values
  '''
  df = df_[df_['cycle']=='start']
  df.index = range(len(df))
  id2trace_ = dict()            
  for id in set(df['ID']):       
      id2trace_[id] = list(df['Event'][df['ID'] == id])
 
  #drop len<=2 traces
  del_list = []
  for i in range(len(df)):
      if  len(id2trace_[df['ID'][i]])<=2 :
          del_list.append(i)
  for i in del_list:
      try:
          del id2trace_[df['ID'][i]]
      except:
          continue
  df = df.drop(del_list, axis=0)
  df.index = range(len(df))

  del_list2 = []
  for id in set(df_['ID']):
      if id not in id2trace_:
          del_list2+= list(df_[df_['ID']==id].index)
  df_ = df_.drop(del_list2, axis=0)
  df_.index = range(len(df_))
  
  return df_,id2trace_

df_, id2trace = df2dict(df_)
con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}")
con.sql(f"CREATE TABLE eventlog_{cond} AS SELECT * FROM df_")
patients = sorted(id2trace.keys())
traces = list(id2trace[id] for id in patients)     
con.close()
```

```{r}
#| label: Loading event log in R (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
log_info('Load {cond} eventlog')
con <- dbConnect(duckdb(), dbdir = db_path)
evLog <- load_log(con, paste0("SELECT * FROM eventlog_",cond))
dbDisconnect(con, shutdown = TRUE)
```

Choosing patients without any predominant clinical condition and after some preprocessing we obtain an event log that can be represented in the below process map @fig-pm1_else. There is shown how the events are connected, the mean number of days patients spent in each event (or treatment), percentage of patients who made each transition and the mean number of days it took to make the transition. However, a spaghetti map is obtained and nothing can be concluded. Therefore, we have to simplify the process map and for example only show the most frequent traces covering 20% of the event log as in @fig-pm02_else. Moreover, in @fig-activity_presence_else we show percentage of patients' traces each activity is present.

```{r}
#| label: proces map 1 (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make {cond} process map')
make_process_map(evLog,1,gsub("src/analysis-scripts/","",
                              here("outputs",sprintf("evlog_pm_1_%s.png",
                                                     cond))))
```

![Event log's process maps with all traces](../../outputs/evlog_pm_1_else.png){#fig-pm1_else fig-align="center" width="80%"}

```{r}
#| label: process map 0.2 (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
make_process_map(evLog,0.2,gsub("src/analysis-scripts/","",
                                here("outputs",sprintf("evlog_pm_02_%s.png",
                                                     cond))))
```

![Event log's process maps with most frequent traces covering 20%](../../outputs/evlog_pm_02_else.png){#fig-pm02_else fig-align="center" width="80%"}

```{r}
#| label: activity presence (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make activity presence of {cond} patients')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("activity_presence_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(evLog %>% activity_presence()  )+scale_y_continuous(limits = c(0, 1))
dev.off()
```

![Percentage of patients' traces an activity is present](../../outputs/activity_presence_else.png){#fig-activity_presence_else fig-align="center" width="80%"}

#### Clustering traces

Once the set of traces to analyze are selected, there is a need to choose a distance measure to clustering. In this example Levenshtein similarity is chosen to calculate the distance matrix.

```{python}
#| label: dm calculation (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make distance matrix of %s patients", cond)
measure_f = Levenshtein.normalized_similarity
dm = calculate_dm_ED(traces,measure_f)
```

When distance matrix is acquired, we are able to cluster. However, the number of clusters have to be fixed before. With these figures we are able to conclude what could be the optimal number of clusters.

```{python}
#| label: dendograms (else)
#| eval: TRUE
#| echo: FALSE
#| output: FALSE
logging.info("Make dendogram of %s patients", cond)
dendogram(dm,'../../outputs/dendogram_%s.png' % cond)
```

```{python}
#| label: kelbow (else)
#| eval: TRUE
#| echo: FALSE
if len(traces)>25:
  n_clusters = kelbow(dm,elbow_metric='distortion',locate_elbow=True)
#kelbow(dm,elbow_metric='calinski_harabasz',locate_elbow=False)
else:
  n_clusters=1
```

![Distance matrix's dendogram](../../outputs/dendogram_else.png){#fig-dendogram_else fig-align="center" width="80%"}

```{python}
#| label: clustering (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make clustering of %s patients", cond)
con = duckdb.connect(db_path)
df_ = clust(n_clusters,dm,df_,id2trace,patients)
con.sql(f"DROP TABLE IF EXISTS clust_{cond}")
con.sql(f"CREATE TABLE clust_{cond} AS SELECT DISTINCT ID,cluster FROM df_")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust")
con.sql(f"CREATE VIEW eventlog_{cond}_clust AS SELECT \
  eventlog_{cond}.ID,date,nid,Event,cycle,actins,cluster FROM eventlog_{cond} \
  LEFT JOIN clust_{cond} ON eventlog_{cond}.ID = clust_{cond}.ID ")
con.sql(f"DROP VIEW IF EXISTS cluster_histogram_{cond}")
con.sql(f"CREATE VIEW cluster_histogram_{cond} AS\
  SELECT cluster, COUNT(DISTINCT ID) AS freq \
  FROM eventlog_{cond}_clust GROUP BY cluster")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust_filtered")
con.sql(f"CREATE VIEW eventlog_{cond}_clust_filtered AS \
   SELECT * FROM eventlog_{cond}_clust \
  WHERE cluster IN (SELECT cluster FROM cluster_histogram_{cond} \
  WHERE freq>=25 OR freq>=(SELECT SUM(freq) * 0.05 \
  FROM cluster_histogram_{cond}))")

del dm
del df_
```

Choosing the optimal number of clusters, too small clusters can appear, but we can exclude those of less than 30 traces to avoid having clusters of low representation. The process map and the most frequent traces of one of these clusters that remain are the followings.

```{python}
#| label: trace explorer (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make trace explorer figures of %s patients", cond)
col_dic = trace_explorer(con,cond)
con.close()
```

```{r}
#| label: process explorer (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make process maps figures of different clusters of {cond} patients')
con <- dbConnect(duckdb(), dbdir = db_path)
process_map_by_cluster(
  load_log(con,
           paste0("SELECT * FROM eventlog_",cond,"_clust_filtered")),
  0.25,cond)
dbDisconnect(con, shutdown = TRUE)
```

::: {#fig-cluster0_else .column-page layout-ncol="2"}
![5 most frequent traces](../../outputs/t_cluster_else_0.png){#fig-traceexplorer0_else}

![Process map covering 25% most frequent traces](../../outputs/pm_cluster_else_0.png){#fig-processmap0_else}

Cluster 0
:::

#### Conformace checking

Once traces are clusterized, with a boxplot is easy to show that each cluster's behavior with respect to the treatment guides is different. Comparing traces with @fig-petrinet_else, calculating the fitness (1 being perfect match with the petri net and 0 being the lowest possible fitness) of each trace and grouping by cluster results in\_ @fig-fitness_by_cluster_else.

```{python}
#| label: fitness boxplot (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make conformance checking analysis of %s patients", cond)
con = duckdb.connect(db_path)
treatments_clusters_boxplot(con,cond,
            pn_file='./PN_%s.pnml' % cond,
            pn_png_file='../../outputs/PN_%s.png' % cond,
            output_png='../../outputs/fitness_by_cluster_%s.png' % cond)
```

![Traces fitness distribution by cluster](../../outputs/fitness_by_cluster_else.png){#fig-fitness_by_cluster_else fig-align="center" width="80%"}

#### Decision mining

In @fig-decision_tree_else is shown how patients' age, sex and copayment would influence in prescribing three drugs based treatment. More features could have been added but for simplicity we included those three.

```{python}
#| label: create decision tree (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make decision making analysis of %s patients", cond)
try:
  decision_tree_pn_place(con,cond,
    pn_file='./PN_%s.pnml' % cond,
    place2analyze='place1')
except Exception as Argument:
  logging.warning(
    "Error occurred when executing decision mining: %s",str(Argument))
  pass
con.close()
```

![Decision tree of place9 (triple treatment prescription step)](../../outputs/decision_tree_else.png){#fig-decision_tree_else fig-align="center" width="80%"}

Variables relevance in the previous decision tree is indicated in @fig-features_relevance_else. As we can see, categorical variables are divided into as many parts as the number of categories there are and variables' total relevance is the sum of its categories' values.

![Features importance in place9 (triple treatment prescription step)](../../outputs/barplot_features_importance_else.png){#fig-features_relevance_else fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependet Cox model, and the summary of it is:

```{python}
#| label: create fitness by period table (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create  %s patients prediction models", cond)
con = duckdb.connect(db_path)
id2treat_fitness_by_interval(con, cond,
            pn_file='./PN_%s.pnml' % cond,
            ini_place='place100',fin_place='place111',
            fixed_period_time=90)
con.close()
```

```{r}
#| label: Time dependent COX (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2fitness_",cond,".ID,period2fitness_",cond,".t_0,period2fitness_",cond,".t_1,period2fitness_",cond,".fitness,period2fitness_",cond,".status,period2fitness_",cond,".status2,patient_incidents_view.age,patient_incidents_view.sex,patient_incidents_view.copayment FROM period2fitness_",cond," LEFT JOIN patient_incidents_view ON period2fitness_",cond,".ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)


model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (else)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class

mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,                  
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint1_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 10, bty = "l", legend.loc = 'bottomright',
     ylab = "fitness", xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1000,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint2_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint3_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)
```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_else.png){#fig-joint1_else fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_else.png){#fig-joint2_else fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_else.png){#fig-joint3_else fig-align="center" width="80%"}

### CV Disease

#### Event log's creation and description

```{python}
#| label: condition variable in python (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond = 'cvd'
```

```{r}
#| label: condition variable in r (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond <- 'cvd'
```

```{python}
#| label: Preprocessing of raw event log (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con = duckdb.connect(db_path)
if notnan_p>0.98:
  logging.info("Generate event log of %s patients from prescriptions", cond)
  evlog_creation_by_prescriptions(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv')
else:
  logging.info("Generate event log of %s patients from dispensations", cond)
  evlog_creation_by_dispensations(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv',
    nac_path='./Nomenclator_de_Facturacion.csv')
```

```{python}
#| label: event log (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Filter event log of %s patients", cond)
df_ = con.sql(f"SELECT * FROM evlog_raw_{cond}").df()

df_, id2trace = df2dict(df_)
con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}")
con.sql(f"CREATE TABLE eventlog_{cond} AS SELECT * FROM df_")
patients = sorted(id2trace.keys())
traces = list(id2trace[id] for id in patients)     
con.close()
```

```{r}
#| label: Loading event log in R (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
log_info('Load {cond} eventlog')
con <- dbConnect(duckdb(), dbdir = db_path)
evLog <- load_log(con, paste0("SELECT * FROM eventlog_",cond))
dbDisconnect(con, shutdown = TRUE)
```

Choosing patients with a cardiovascular disease and after some preprocessing we obtain a new event log to make the same analysis it has done to patients without any predominant clinical condition.

```{r}
#| label: proces map 1 (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make {cond} process map')
make_process_map(evLog,1,gsub("src/analysis-scripts/","",
                              here("outputs",sprintf("evlog_pm_1_%s.png",
                                                     cond))))
```

![Event log's process maps with all traces](../../outputs/evlog_pm_1_cvd.png){#fig-pm1_cvd fig-align="center" width="80%"}

```{r}
#| label: process map 0.2 (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
make_process_map(evLog,0.2,gsub("src/analysis-scripts/","",
                                here("outputs",sprintf("evlog_pm_02_%s.png",
                                                     cond))))
```

![Event log's process maps with most frequent traces covering 20%](../../outputs/evlog_pm_02_cvd.png){#fig-pm02_cvd fig-align="center" width="80%"}

```{r}
#| label: activity presence (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make activity presence of {cond} patients')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("activity_presence_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(evLog %>% activity_presence()  )+scale_y_continuous(limits = c(0, 1))
dev.off()
```

![Percentage of patients' traces an activity is present](../../outputs/activity_presence_cvd.png){#fig-activity_presence_cvd fig-align="center" width="80%"}

#### Clustering traces

```{python}
#| label: dm calculation (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make distance matrix of %s patients", cond)
measure_f = Levenshtein.normalized_similarity
dm = calculate_dm_ED(traces,measure_f)
```

```{python}
#| label: dendograms (cvd)
#| eval: TRUE
#| echo: FALSE
#| output: FALSE
logging.info("Make dendogram of %s patients", cond)
dendogram(dm,'../../outputs/dendogram_%s.png' % cond)
```

```{python}
#| label: kelbow (cvd)
#| eval: TRUE
#| echo: FALSE
if len(traces)>25:
  n_clusters = kelbow(dm,elbow_metric='distortion',locate_elbow=True)
#kelbow(dm,elbow_metric='calinski_harabasz',locate_elbow=False)
else:
  n_clusters=1
```

![Distance matrix's dendogram](../../outputs/dendogram_cvd.png){#fig-dendogram_cvd fig-align="center" width="80%"}

```{python}
#| label: clustering (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make clustering of %s patients", cond)
con = duckdb.connect(db_path)
df_ = clust(n_clusters,dm,df_,id2trace,patients)
con.sql(f"DROP TABLE IF EXISTS clust_{cond}")
con.sql(f"CREATE TABLE clust_{cond} AS SELECT DISTINCT ID,cluster FROM df_")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust")
con.sql(f"CREATE VIEW eventlog_{cond}_clust AS SELECT \
  eventlog_{cond}.ID,date,nid,Event,cycle,actins,cluster FROM eventlog_{cond} \
  LEFT JOIN clust_{cond} ON eventlog_{cond}.ID = clust_{cond}.ID ")
con.sql(f"DROP VIEW IF EXISTS cluster_histogram_{cond}")
con.sql(f"CREATE VIEW cluster_histogram_{cond} AS\
  SELECT cluster, COUNT(DISTINCT ID) AS freq \
  FROM eventlog_{cond}_clust GROUP BY cluster")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust_filtered")
con.sql(f"CREATE VIEW eventlog_{cond}_clust_filtered AS \
   SELECT * FROM eventlog_{cond}_clust \
  WHERE cluster IN (SELECT cluster FROM cluster_histogram_{cond} \
  WHERE freq>=25 OR freq>=(SELECT SUM(freq) * 0.05 \
  FROM cluster_histogram_{cond}))")

```

```{python}
#| label: trace explorer (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make trace explorer figures of %s patients", cond)
col_dic = trace_explorer(con,cond,color_dict=col_dic)
con.close()
```

```{r}
#| label: process explorer (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make process maps figures of different clusters of {cond} patients')
con <- dbConnect(duckdb(), dbdir = db_path)
process_map_by_cluster(
  load_log(con,
           paste0("SELECT * FROM eventlog_",cond,"_clust_filtered")),
  0.25,cond)
dbDisconnect(con, shutdown = TRUE)
```

::: {#fig-cluster0_cvd .column-page layout-ncol="2"}
![5 most frequent traces](../../outputs/t_cluster_cvd_0.png){#fig-traceexplorer0_cvd}

![Process map covering 25% most frequent traces](../../outputs/pm_cluster_cvd_0.png){#fig-processmap0_cvd}

Cluster 0
:::

#### Conformace checking

```{python}
#| label: fitness boxplot (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make conformance checking analysis of %s patients", cond)
con = duckdb.connect(db_path)
treatments_clusters_boxplot(con,cond,
            pn_file='./PN_%s.pnml' % cond,
            pn_png_file='../../outputs/PN_%s.png' % cond,
            output_png='../../outputs/fitness_by_cluster_%s.png' % cond)
```

![Traces fitness distribution by cluster](../../outputs/fitness_by_cluster_cvd.png){#fig-fitness_by_cluster_cvd fig-align="center" width="80%"}

#### Decision mining

```{python}
#| label: create decision tree (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make decision making analysis of %s patients", cond)
try:
  decision_tree_pn_place(con,cond,
    pn_file='./PN_%s.pnml' % cond,
    place2analyze='place1')
except Exception as Argument:
  logging.warning(
    "Error occurred when executing decision mining: %s",str(Argument))
  pass
con.close()
```

![Decision tree of place9 (triple treatment prescription step)](../../outputs/decision_tree_cvd.png){#fig-decision_tree_cvd fig-align="center" width="80%"}

![Features importance in place9 (triple treatment prescription step)](../../outputs/barplot_features_importance_cvd.png){#fig-features_relevance_cvd fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependet Cox model, and the summary of it is:

```{python}
#| label: create fitness by period table (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create  %s patients prediction models", cond)
con = duckdb.connect(db_path)
id2treat_fitness_by_interval(con, cond,
            pn_file='./PN_%s.pnml' % cond,
            ini_place='place100',fin_place='place111',
            fixed_period_time=90)
con.close()
```

```{r}
#| label: Time dependent COX (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2fitness_",cond,".ID,period2fitness_",cond,".t_0,period2fitness_",cond,".t_1,period2fitness_",cond,".fitness,period2fitness_",cond,".status,period2fitness_",cond,".status2,patient_incidents_view.age,patient_incidents_view.sex,patient_incidents_view.copayment FROM period2fitness_",cond," LEFT JOIN patient_incidents_view ON period2fitness_",cond,".ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)

model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (cvd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class

mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,                  
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint1_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 10, bty = "l", legend.loc = 'bottomright',
     ylab = "fitness", xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1000,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint2_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint3_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)

```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_cvd.png){#fig-joint1_cvd fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_cvd.png){#fig-joint2_cvd fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_cvd.png){#fig-joint3_cvd fig-align="center" width="80%"}

### Heart Failure

#### Event log's creation and description

```{python}
#| label: condition variable in python (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond = 'hf'
```

```{r}
#| label: condition variable in r (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond <- 'hf'
```

```{python}
#| label: Preprocessing of raw event log (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con = duckdb.connect(db_path)
if notnan_p>0.98:
  logging.info("Generate event log of %s patients from prescriptions", cond)
  evlog_creation_by_prescriptions(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv')
else:
  logging.info("Generate event log of %s patients from dispensations", cond)
  evlog_creation_by_dispensations(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv',
    nac_path='./Nomenclator_de_Facturacion.csv')
```

```{python}
#| label: event log (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Filter event log of %s patients", cond)
df_ = con.sql(f"SELECT * FROM evlog_raw_{cond}").df()

df_, id2trace = df2dict(df_)
con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}")
con.sql(f"CREATE TABLE eventlog_{cond} AS SELECT * FROM df_")
patients = sorted(id2trace.keys())
traces = list(id2trace[id] for id in patients)     
con.close()
```

```{r}
#| label: Loading event log in R (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
log_info('Load {cond} eventlog')
con <- dbConnect(duckdb(), dbdir = db_path)
evLog <- load_log(con, paste0("SELECT * FROM eventlog_",cond))
dbDisconnect(con, shutdown = TRUE)
```

Choosing patients with heart failure and after some preprocessing we obtain a new event log to make the same analysis it has done to patients without any predominant clinical condition.

```{r}
#| label: proces map 1 (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make {cond} process map')
make_process_map(evLog,1,gsub("src/analysis-scripts/","",
                              here("outputs",sprintf("evlog_pm_1_%s.png",
                                                     cond))))
```

![Event log's process maps with all traces](../../outputs/evlog_pm_1_hf.png){#fig-pm1_hf fig-align="center" width="80%"}

```{r}
#| label: process map 0.2 (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
make_process_map(evLog,0.2,gsub("src/analysis-scripts/","",
                                here("outputs",sprintf("evlog_pm_02_%s.png",
                                                     cond))))
```

![Event log's process maps with most frequent traces covering 20%](../../outputs/evlog_pm_02_hf.png){#fig-pm02_hf fig-align="center" width="80%"}

```{r}
#| label: activity presence (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make activity presence of {cond} patients')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("activity_presence_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(evLog %>% activity_presence()  )+scale_y_continuous(limits = c(0, 1))
dev.off()
```

![Percentage of patients' traces an activity is present](../../outputs/activity_presence_hf.png){#fig-activity_presence_hf fig-align="center" width="80%"}

#### Clustering traces

```{python}
#| label: dm calculation (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make distance matrix of %s patients", cond)
measure_f = Levenshtein.normalized_similarity
dm = calculate_dm_ED(traces,measure_f)
```

```{python}
#| label: dendograms (hf)
#| eval: TRUE
#| echo: FALSE
#| output: FALSE
logging.info("Make dendogram of %s patients", cond)
dendogram(dm,'../../outputs/dendogram_%s.png' % cond)
```

```{python}
#| label: kelbow (hf)
#| eval: TRUE
#| echo: FALSE
if len(traces)>25:
  n_clusters = kelbow(dm,elbow_metric='distortion',locate_elbow=True)
#kelbow(dm,elbow_metric='calinski_harabasz',locate_elbow=False)
else:
  n_clusters=1
```

![Distance matrix's dendogram](../../outputs/dendogram_hf.png){#fig-dendogram_hf fig-align="center" width="80%"}

```{python}
#| label: clustering (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make clustering of %s patients", cond)
con = duckdb.connect(db_path)
df_ = clust(n_clusters,dm,df_,id2trace,patients)
con.sql(f"DROP TABLE IF EXISTS clust_{cond}")
con.sql(f"CREATE TABLE clust_{cond} AS SELECT DISTINCT ID,cluster FROM df_")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust")
con.sql(f"CREATE VIEW eventlog_{cond}_clust AS SELECT \
  eventlog_{cond}.ID,date,nid,Event,cycle,actins,cluster FROM eventlog_{cond} \
  LEFT JOIN clust_{cond} ON eventlog_{cond}.ID = clust_{cond}.ID ")
con.sql(f"DROP VIEW IF EXISTS cluster_histogram_{cond}")
con.sql(f"CREATE VIEW cluster_histogram_{cond} AS\
  SELECT cluster, COUNT(DISTINCT ID) AS freq \
  FROM eventlog_{cond}_clust GROUP BY cluster")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust_filtered")
con.sql(f"CREATE VIEW eventlog_{cond}_clust_filtered AS \
   SELECT * FROM eventlog_{cond}_clust \
  WHERE cluster IN (SELECT cluster FROM cluster_histogram_{cond} \
  WHERE freq>=25 OR freq>=(SELECT SUM(freq) * 0.05 \
  FROM cluster_histogram_{cond}))")

```

```{python}
#| label: trace explorer (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make trace explorer figures of %s patients", cond)
col_dic = trace_explorer(con,cond,color_dict=col_dic)
con.close()
```

```{r}
#| label: process explorer (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make process maps figures of different clusters of {cond} patients')
con <- dbConnect(duckdb(), dbdir = db_path)
process_map_by_cluster(
  load_log(con,
           paste0("SELECT * FROM eventlog_",cond,"_clust_filtered")),
  0.25,cond)
dbDisconnect(con, shutdown = TRUE)
```

::: {#fig-cluster0_hf .column-page layout-ncol="2"}
![5 most frequent traces](../../outputs/t_cluster_hf_0.png){#fig-traceexplorer0_hf}

![Process map covering 25% most frequent traces](../../outputs/pm_cluster_hf_0.png){#fig-processmap0_hf}

Cluster 0
:::

#### Conformace checking

```{python}
#| label: fitness boxplot (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make conformance checking analysis of %s patients", cond)
con = duckdb.connect(db_path)
treatments_clusters_boxplot(con,cond,
            pn_file='./PN_%s.pnml' % cond,
            pn_png_file='../../outputs/PN_%s.png' % cond,
            output_png='../../outputs/fitness_by_cluster_%s.png' % cond)
```

![Traces fitness distribution by cluster](../../outputs/fitness_by_cluster_hf.png){#fig-fitness_by_cluster_hf fig-align="center" width="80%"}

#### Decision mining

```{python}
#| label: create decision tree (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make decision making analysis of %s patients", cond)
try:
  decision_tree_pn_place(con,cond,
    pn_file='./PN_%s.pnml' % cond,
    place2analyze='place1')
except Exception as Argument:
  logging.warning(
    "Error occurred when executing decision mining: %s",str(Argument))
  pass
con.close()
```

![Decision tree of place9 (triple treatment prescription step)](../../outputs/decision_tree_hf.png){#fig-decision_tree_hf fig-align="center" width="80%"}

![Features importance in place9 (triple treatment prescription step)](../../outputs/barplot_features_importance_hf.png){#fig-features_relevance_hf fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependet Cox model, and the summary of it is:

```{python}
#| label: create fitness by period table (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create  %s patients prediction models", cond)
con = duckdb.connect(db_path)
id2treat_fitness_by_interval(con, cond,
            pn_file='./PN_%s.pnml' % cond,
            ini_place='place100',fin_place='place111',
            fixed_period_time=90)
con.close()
```

```{r}
#| label: Time dependent COX (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2fitness_",cond,".ID,period2fitness_",cond,".t_0,period2fitness_",cond,".t_1,period2fitness_",cond,".fitness,period2fitness_",cond,".status,period2fitness_",cond,".status2,patient_incidents_view.age,patient_incidents_view.sex,patient_incidents_view.copayment FROM period2fitness_",cond," LEFT JOIN patient_incidents_view ON period2fitness_",cond,".ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)

model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (hf)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class

mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,                  
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint1_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 10, bty = "l", legend.loc = 'bottomright',
     ylab = "fitness", xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1000,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint2_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint3_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)

```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_hf.png){#fig-joint1_hf fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_hf.png){#fig-joint2_hf fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_hf.png){#fig-joint3_hf fig-align="center" width="80%"}


### Chronic kidney disease

#### Event log's creation and description

```{python}
#| label: condition variable in python (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond = 'ckd'
```

```{r}
#| label: condition variable in r (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond <- 'ckd'
```

```{python}
#| label: Preprocessing of raw event log (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con = duckdb.connect(db_path)
if notnan_p>0.98:
  logging.info("Generate event log of %s patients from prescriptions", cond)
  evlog_creation_by_prescriptions(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv')
else:
  logging.info("Generate event log of %s patients from dispensations", cond)
  evlog_creation_by_dispensations(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv',
    nac_path='./Nomenclator_de_Facturacion.csv')
```

```{python}
#| label: event log (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Filter event log of %s patients", cond)
df_ = con.sql(f"SELECT * FROM evlog_raw_{cond}").df()

df_, id2trace = df2dict(df_)
con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}")
con.sql(f"CREATE TABLE eventlog_{cond} AS SELECT * FROM df_")
patients = sorted(id2trace.keys())
traces = list(id2trace[id] for id in patients)     
con.close()
```

```{r}
#| label: Loading event log in R (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
log_info('Load {cond} eventlog')
con <- dbConnect(duckdb(), dbdir = db_path)
evLog <- load_log(con, paste0("SELECT * FROM eventlog_",cond))
dbDisconnect(con, shutdown = TRUE)
```

Choosing patients with chronic kidney disease and after some preprocessing we obtain a new event log to make the same analysis it has done to patients without any predominant clinical condition.

```{r}
#| label: proces map 1 (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make {cond} process map')
make_process_map(evLog,1,gsub("src/analysis-scripts/","",
                              here("outputs",sprintf("evlog_pm_1_%s.png",
                                                     cond))))
```

![Event log's process maps with all traces](../../outputs/evlog_pm_1_ckd.png){#fig-pm1_ckd fig-align="center" width="80%"}

```{r}
#| label: process map 0.2 (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
make_process_map(evLog,0.2,gsub("src/analysis-scripts/","",
                                here("outputs",sprintf("evlog_pm_02_%s.png",
                                                     cond))))
```

![Event log's process maps with most frequent traces covering 20%](../../outputs/evlog_pm_02_ckd.png){#fig-pm02_ckd fig-align="center" width="80%"}

```{r}
#| label: activity presence (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make activity presence of {cond} patients')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("activity_presence_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(evLog %>% activity_presence()  )+scale_y_continuous(limits = c(0, 1))
dev.off()
```

![Percentage of patients' traces an activity is present](../../outputs/activity_presence_ckd.png){#fig-activity_presence_ckd fig-align="center" width="80%"}

#### Clustering traces

```{python}
#| label: dm calculation (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make distance matrix of %s patients", cond)
measure_f = Levenshtein.normalized_similarity
dm = calculate_dm_ED(traces,measure_f)
```

```{python}
#| label: dendograms (ckd)
#| eval: TRUE
#| echo: FALSE
#| output: FALSE
logging.info("Make dendogram of %s patients", cond)
dendogram(dm,'../../outputs/dendogram_%s.png' % cond)
```

```{python}
#| label: kelbow (ckd)
#| eval: TRUE
#| echo: FALSE
if len(traces)>25:
  n_clusters = kelbow(dm,elbow_metric='distortion',locate_elbow=True)
#kelbow(dm,elbow_metric='calinski_harabasz',locate_elbow=False)
else:
  n_clusters=1
```

![Distance matrix's dendogram](../../outputs/dendogram_ckd.png){#fig-dendogram_ckd fig-align="center" width="80%"}

```{python}
#| label: clustering (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make clustering of %s patients", cond)
con = duckdb.connect(db_path)
df_ = clust(n_clusters,dm,df_,id2trace,patients)
con.sql(f"DROP TABLE IF EXISTS clust_{cond}")
con.sql(f"CREATE TABLE clust_{cond} AS SELECT DISTINCT ID,cluster FROM df_")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust")
con.sql(f"CREATE VIEW eventlog_{cond}_clust AS SELECT \
  eventlog_{cond}.ID,date,nid,Event,cycle,actins,cluster FROM eventlog_{cond} \
  LEFT JOIN clust_{cond} ON eventlog_{cond}.ID = clust_{cond}.ID ")
con.sql(f"DROP VIEW IF EXISTS cluster_histogram_{cond}")
con.sql(f"CREATE VIEW cluster_histogram_{cond} AS\
  SELECT cluster, COUNT(DISTINCT ID) AS freq \
  FROM eventlog_{cond}_clust GROUP BY cluster")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust_filtered")
con.sql(f"CREATE VIEW eventlog_{cond}_clust_filtered AS \
   SELECT * FROM eventlog_{cond}_clust \
  WHERE cluster IN (SELECT cluster FROM cluster_histogram_{cond} \
  WHERE freq>=25 OR freq>=(SELECT SUM(freq) * 0.05 \
  FROM cluster_histogram_{cond}))")

```

```{python}
#| label: trace explorer (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make trace explorer figures of %s patients", cond)
col_dic = trace_explorer(con,cond,color_dict=col_dic)
con.close()
```

```{r}
#| label: process explorer (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make process maps figures of different clusters of {cond} patients')
con <- dbConnect(duckdb(), dbdir = db_path)
process_map_by_cluster(
  load_log(con,
           paste0("SELECT * FROM eventlog_",cond,"_clust_filtered")),
  0.25,cond)
dbDisconnect(con, shutdown = TRUE)
```

::: {#fig-cluster0_ckd .column-page layout-ncol="2"}
![5 most frequent traces](../../outputs/t_cluster_ckd_0.png){#fig-traceexplorer0_ckd}

![Process map covering 25% most frequent traces](../../outputs/pm_cluster_ckd_0.png){#fig-processmap0_ckd}

Cluster 0
:::

#### Conformace checking

```{python}
#| label: fitness boxplot (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make conformance checking analysis of %s patients", cond)
con = duckdb.connect(db_path)
treatments_clusters_boxplot(con,cond,
            pn_file='./PN_%s.pnml' % cond,
            pn_png_file='../../outputs/PN_%s.png' % cond,
            output_png='../../outputs/fitness_by_cluster_%s.png' % cond)
```

![Traces fitness distribution by cluster](../../outputs/fitness_by_cluster_ckd.png){#fig-fitness_by_cluster_ckd fig-align="center" width="80%"}

#### Decision mining

```{python}
#| label: create decision tree (ckd)
#| eval: FALSE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make decision making analysis of %s patients", cond)
try:
  decision_tree_pn_place(con,cond,
    pn_file='./PN_%s.pnml' % cond,
    place2analyze='place1')
except Exception as Argument:
  logging.warning(
    "Error occurred when executing decision mining: %s",str(Argument))
  pass
con.close()

```

![Decision tree of place9 (triple treatment prescription step)](../../outputs/decision_tree_ckd.png){#fig-decision_tree_ckd fig-align="center" width="80%"}

![Features importance in place9 (triple treatment prescription step)](../../outputs/barplot_features_importance_ckd.png){#fig-features_relevance_ckd fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependet Cox model, and the summary of it is:

```{python}
#| label: create fitness by period table (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create  %s patients prediction models", cond)
con = duckdb.connect(db_path)
id2treat_fitness_by_interval(con, cond,
            pn_file='./PN_%s.pnml' % cond,
            ini_place='place100',fin_place='place111',
            fixed_period_time=90)
con.close()
```

```{r}
#| label: Time dependent COX (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2fitness_",cond,".ID,period2fitness_",cond,".t_0,period2fitness_",cond,".t_1,period2fitness_",cond,".fitness,period2fitness_",cond,".status,period2fitness_",cond,".status2,patient_incidents_view.age,patient_incidents_view.sex,patient_incidents_view.copayment FROM period2fitness_",cond," LEFT JOIN patient_incidents_view ON period2fitness_",cond,".ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)

model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (ckd)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class

mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,                  
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint1_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 10, bty = "l", legend.loc = 'bottomright',
     ylab = "fitness", xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1000,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint2_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint3_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)

```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_ckd.png){#fig-joint1_ckd fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_ckd.png){#fig-joint2_ckd fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_ckd.png){#fig-joint3_ckd fig-align="center" width="80%"}

### Frailty

#### Event log's creation and description

```{python}
#| label: condition variable in python (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond = 'f'
```

```{r}
#| label: condition variable in r (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond <- 'f'
```

```{python}
#| label: Preprocessing of raw event log (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con = duckdb.connect(db_path)
if notnan_p>0.98:
  logging.info("Generate event log of %s patients from prescriptions", cond)
  evlog_creation_by_prescriptions(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv')
else:
  logging.info("Generate event log of %s patients from dispensations", cond)
  evlog_creation_by_dispensations(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv',
    nac_path='./Nomenclator_de_Facturacion.csv')
```

```{python}
#| label: event log (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Filter event log of %s patients", cond)
df_ = con.sql(f"SELECT * FROM evlog_raw_{cond}").df()

df_, id2trace = df2dict(df_)
con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}")
con.sql(f"CREATE TABLE eventlog_{cond} AS SELECT * FROM df_")
patients = sorted(id2trace.keys())
traces = list(id2trace[id] for id in patients)     
con.close()
```

```{r}
#| label: Loading event log in R (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
log_info('Load {cond} eventlog')
con <- dbConnect(duckdb(), dbdir = db_path)
evLog <- load_log(con, paste0("SELECT * FROM eventlog_",cond))
dbDisconnect(con, shutdown = TRUE)
```

Choosing patients with frailty and after some preprocessing we obtain a new event log to make the same analysis it has done to patients without any predominant clinical condition.

```{r}
#| label: proces map 1 (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make {cond} process map')
make_process_map(evLog,1,gsub("src/analysis-scripts/","",
                              here("outputs",sprintf("evlog_pm_1_%s.png",
                                                     cond))))
```

![Event log's process maps with all traces](../../outputs/evlog_pm_1_f.png){#fig-pm1_f fig-align="center" width="80%"}

```{r}
#| label: process map 0.2 (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
make_process_map(evLog,0.2,gsub("src/analysis-scripts/","",
                                here("outputs",sprintf("evlog_pm_02_%s.png",
                                                     cond))))
```

![Event log's process maps with most frequent traces covering 20%](../../outputs/evlog_pm_02_f.png){#fig-pm02_f fig-align="center" width="80%"}

```{r}
#| label: activity presence (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make activity presence of {cond} patients')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("activity_presence_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(evLog %>% activity_presence()  )+scale_y_continuous(limits = c(0, 1))
dev.off()
```

![Percentage of patients' traces an activity is present](../../outputs/activity_presence_f.png){#fig-activity_presence_f fig-align="center" width="80%"}

#### Clustering traces

```{python}
#| label: dm calculation (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make distance matrix of %s patients", cond)
measure_f = Levenshtein.normalized_similarity
dm = calculate_dm_ED(traces,measure_f)
```

```{python}
#| label: dendograms (f)
#| eval: TRUE
#| echo: FALSE
#| output: FALSE
logging.info("Make dendogram of %s patients", cond)
dendogram(dm,'../../outputs/dendogram_%s.png' % cond)
```

```{python}
#| label: kelbow (f)
#| eval: TRUE
#| echo: FALSE
if len(traces)>25:
  n_clusters = kelbow(dm,elbow_metric='distortion',locate_elbow=True)
#kelbow(dm,elbow_metric='calinski_harabasz',locate_elbow=False)
else:
  n_clusters=1
```

![Distance matrix's dendogram](../../outputs/dendogram_f.png){#fig-dendogram fig-align="center" width="80%"}

```{python}
#| label: clustering (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make clustering of %s patients", cond)
con = duckdb.connect(db_path)
df_ = clust(n_clusters,dm,df_,id2trace,patients)
con.sql(f"DROP TABLE IF EXISTS clust_{cond}")
con.sql(f"CREATE TABLE clust_{cond} AS SELECT DISTINCT ID,cluster FROM df_")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust")
con.sql(f"CREATE VIEW eventlog_{cond}_clust AS SELECT \
  eventlog_{cond}.ID,date,nid,Event,cycle,actins,cluster FROM eventlog_{cond} \
  LEFT JOIN clust_{cond} ON eventlog_{cond}.ID = clust_{cond}.ID ")
con.sql(f"DROP VIEW IF EXISTS cluster_histogram_{cond}")
con.sql(f"CREATE VIEW cluster_histogram_{cond} AS\
  SELECT cluster, COUNT(DISTINCT ID) AS freq \
  FROM eventlog_{cond}_clust GROUP BY cluster")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust_filtered")
con.sql(f"CREATE VIEW eventlog_{cond}_clust_filtered AS \
   SELECT * FROM eventlog_{cond}_clust \
  WHERE cluster IN (SELECT cluster FROM cluster_histogram_{cond} \
  WHERE freq>=25 OR freq>=(SELECT SUM(freq) * 0.05 \
  FROM cluster_histogram_{cond}))")

```

```{python}
#| label: trace explorer (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make trace explorer figures of %s patients", cond)
col_dic = trace_explorer(con,cond,color_dict=col_dic)
con.close()
```

```{r}
#| label: process explorer (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make process maps figures of different clusters of {cond} patients')
con <- dbConnect(duckdb(), dbdir = db_path)
process_map_by_cluster(
  load_log(con,
           paste0("SELECT * FROM eventlog_",cond,"_clust_filtered")),
  0.25,cond)
dbDisconnect(con, shutdown = TRUE)
```

::: {#fig-cluster0_f .column-page layout-ncol="2"}
![5 most frequent traces](../../outputs/t_cluster_f_0.png){#fig-traceexplorer0}

![Process map covering 25% most frequent traces](../../outputs/pm_cluster_f_0.png){#fig-processmap0}

Cluster 0
:::

#### Conformace checking

```{python}
#| label: fitness boxplot (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make conformance checking analysis of %s patients", cond)
con = duckdb.connect(db_path)
treatments_clusters_boxplot(con,cond,
            pn_file='./PN_%s.pnml' % cond,
            pn_png_file='../../outputs/PN_%s.png' % cond,
            output_png='../../outputs/fitness_by_cluster_%s.png' % cond)
```

![Traces fitness distribution by cluster](../../outputs/fitness_by_cluster_f.png){#fig-fitness_by_cluster_f fig-align="center" width="80%"}

#### Decision mining

```{python}
#| label: create decision tree (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make decision making analysis of %s patients", cond)
try:
  decision_tree_pn_place(con,cond,
    pn_file='./PN_%s.pnml' % cond,
    place2analyze='place1')
except Exception as Argument:
  logging.warning(
    "Error occurred when executing decision mining: %s",str(Argument))
  pass
con.close()
```

![Decision tree of place9 (triple treatment prescription step)](../../outputs/decision_tree_f.png){#fig-decision_tree_f fig-align="center" width="80%"}

![Features importance in place9 (triple treatment prescription step)](../../outputs/barplot_features_importance_f.png){#fig-features_relevance_f fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependet Cox model, and the summary of it is:

```{python}
#| label: create fitness by period table (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create  %s patients prediction models", cond)
con = duckdb.connect(db_path)
id2treat_fitness_by_interval(con, cond,
            pn_file='./PN_%s.pnml' % cond,
            ini_place='place100',fin_place='place111',
            fixed_period_time=90)
con.close()
```

```{r}
#| label: Time dependent COX (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2fitness_",cond,".ID,period2fitness_",cond,".t_0,period2fitness_",cond,".t_1,period2fitness_",cond,".fitness,period2fitness_",cond,".status,period2fitness_",cond,".status2,patient_incidents_view.age,patient_incidents_view.sex,patient_incidents_view.copayment FROM period2fitness_",cond," LEFT JOIN patient_incidents_view ON period2fitness_",cond,".ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)

model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (f)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class

mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,                  
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint1_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 10, bty = "l", legend.loc = 'bottomright',
     ylab = "fitness", xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1000,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint2_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint3_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)

```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_f.png){#fig-joint1_f fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_f.png){#fig-joint2_f fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_f.png){#fig-joint3_f fig-align="center" width="80%"}

### Obesity

#### Event log's creation and description

```{python}
#| label: condition variable in python (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond = 'ob'
```

```{r}
#| label: condition variable in r (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
cond <- 'ob'
```

```{python}
#| label: Preprocessing of raw event log (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con = duckdb.connect(db_path)
if notnan_p>0.98:
  logging.info("Generate event log of %s patients from prescriptions", cond)
  evlog_creation_by_prescriptions(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv')
else:
  logging.info("Generate event log of %s patients from dispensations", cond)
  evlog_creation_by_dispensations(
    con=con,
    cond=cond,
    code2drug_info_path='./diabetes_drugs.csv',
    nac_path='./Nomenclator_de_Facturacion.csv')
```

```{python}
#| label: event log (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Filter event log of %s patients", cond)
df_ = con.sql(f"SELECT * FROM evlog_raw_{cond}").df()

df_, id2trace = df2dict(df_)
con.sql(f"DROP TABLE IF EXISTS eventlog_{cond}")
con.sql(f"CREATE TABLE eventlog_{cond} AS SELECT * FROM df_")
patients = sorted(id2trace.keys())
traces = list(id2trace[id] for id in patients)     
con.close()
```

```{r}
#| label: Loading event log in R (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
log_info('Load {cond} eventlog')
con <- dbConnect(duckdb(), dbdir = db_path)
evLog <- load_log(con, paste0("SELECT * FROM eventlog_",cond))
dbDisconnect(con, shutdown = TRUE)
```

Choosing patients with obesity and after some preprocessing we obtain a new event log to make the same analysis it has done to patients without any predominant clinical condition.

```{r}
#| label: proces map 1 (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make {cond} process map')
make_process_map(evLog,1,gsub("src/analysis-scripts/","",
                              here("outputs",sprintf("evlog_pm_1_%s.png",
                                                     cond))))
```

![Event log's process maps with all traces](../../outputs/evlog_pm_1_ob.png){#fig-pm1_ob fig-align="center" width="80%"}

```{r}
#| label: process map 0.2 (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
make_process_map(evLog,0.2,gsub("src/analysis-scripts/","",
                                here("outputs",sprintf("evlog_pm_02_%s.png",
                                                     cond))))
```

![Event log's process maps with most frequent traces covering 20%](../../outputs/evlog_pm_02_ob.png){#fig-pm02_ob fig-align="center" width="80%"}

```{r}
#| label: activity presence (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make activity presence of {cond} patients')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("activity_presence_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(evLog %>% activity_presence()  )+scale_y_continuous(limits = c(0, 1))
dev.off()
```

![Percentage of patients' traces an activity is present](../../outputs/activity_presence_ob.png){#fig-activity_presence_ob fig-align="center" width="80%"}

#### Clustering traces

```{python}
#| label: dm calculation (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make distance matrix of %s patients", cond)
measure_f = Levenshtein.normalized_similarity
dm = calculate_dm_ED(traces,measure_f)
```

```{python}
#| label: dendograms (ob)
#| eval: TRUE
#| echo: FALSE
#| output: FALSE
logging.info("Make dendogram of %s patients", cond)
dendogram(dm,'../../outputs/dendogram_%s.png' % cond)
```

```{python}
#| label: kelbow (ob)
#| eval: TRUE
#| echo: FALSE
if len(traces)>25:
  n_clusters = kelbow(dm,elbow_metric='distortion',locate_elbow=True)
#kelbow(dm,elbow_metric='calinski_harabasz',locate_elbow=False)
else:
  n_clusters=1
```

![Distance matrix's dendogram](../../outputs/dendogram_f.png){fig-align="center" width="80%"}

```{python}
#| label: clustering (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make clustering of %s patients", cond)
con = duckdb.connect(db_path)
df_ = clust(n_clusters,dm,df_,id2trace,patients)
con.sql(f"DROP TABLE IF EXISTS clust_{cond}")
con.sql(f"CREATE TABLE clust_{cond} AS SELECT DISTINCT ID,cluster FROM df_")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust")
con.sql(f"CREATE VIEW eventlog_{cond}_clust AS SELECT \
  eventlog_{cond}.ID,date,nid,Event,cycle,actins,cluster FROM eventlog_{cond} \
  LEFT JOIN clust_{cond} ON eventlog_{cond}.ID = clust_{cond}.ID ")
con.sql(f"DROP VIEW IF EXISTS cluster_histogram_{cond}")
con.sql(f"CREATE VIEW cluster_histogram_{cond} AS\
  SELECT cluster, COUNT(DISTINCT ID) AS freq \
  FROM eventlog_{cond}_clust GROUP BY cluster")
con.sql(f"DROP VIEW IF EXISTS eventlog_{cond}_clust_filtered")
con.sql(f"CREATE VIEW eventlog_{cond}_clust_filtered AS \
   SELECT * FROM eventlog_{cond}_clust \
  WHERE cluster IN (SELECT cluster FROM cluster_histogram_{cond} \
  WHERE freq>=25 OR freq>=(SELECT SUM(freq) * 0.05 \
  FROM cluster_histogram_{cond}))")

```

```{python}
#| label: trace explorer (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make trace explorer figures of %s patients", cond)
col_dic = trace_explorer(con,cond,color_dict=col_dic)
con.close()
```

```{r}
#| label: process explorer (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
log_info('Make process maps figures of different clusters of {cond} patients')
con <- dbConnect(duckdb(), dbdir = db_path)
process_map_by_cluster(
  load_log(con,
           paste0("SELECT * FROM eventlog_",cond,"_clust_filtered")),
  0.25,cond)
dbDisconnect(con, shutdown = TRUE)
```

::: {#fig-cluster0_ob .column-page layout-ncol="2"}
![5 most frequent traces](../../outputs/t_cluster_ob_0.png){#fig-traceexplorer0_ob}

![Process map covering 25% most frequent traces](../../outputs/pm_cluster_ob_0.png){#fig-processmap0_ob}

Cluster 0
:::

#### Conformace checking

```{python}
#| label: fitness boxplot (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make conformance checking analysis of %s patients", cond)
con = duckdb.connect(db_path)
treatments_clusters_boxplot(con,cond,
            pn_file='./PN_%s.pnml' % cond,
            pn_png_file='../../outputs/PN_%s.png' % cond,
            output_png='../../outputs/fitness_by_cluster_%s.png' % cond)
```

![Traces fitness distribution by cluster](../../outputs/fitness_by_cluster_ob.png){#fig-fitness_by_cluster_ob fig-align="center" width="80%"}

#### Decision mining

```{python}
#| label: create decision tree (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Make decision making analysis of %s patients", cond)
try:
  decision_tree_pn_place(con,cond,
    pn_file='./PN_%s.pnml' % cond,
    place2analyze='place1')
except Exception as Argument:
  logging.warning(
    "Error occurred when executing decision mining: %s",str(Argument))
  pass
con.close()
```

![Decision tree of place9 (triple treatment prescription step)](../../outputs/decision_tree_ob.png){#fig-decision_tree_ob fig-align="center" width="80%"}

![Features importance in place9 (triple treatment prescription step)](../../outputs/barplot_features_importance_ob.png){#fig-features_relevance_ob fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependet Cox model, and the summary of it is:

```{python}
#| label: create fitness by period table (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create  %s patients prediction models", cond)
con = duckdb.connect(db_path)
id2treat_fitness_by_interval(con, cond,
            pn_file='./PN_%s.pnml' % cond,
            ini_place='place100',fin_place='place111',
            fixed_period_time=90)
con.close()
```

```{r}
#| label: Time dependent COX (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2fitness_",cond,".ID,period2fitness_",cond,".t_0,period2fitness_",cond,".t_1,period2fitness_",cond,".fitness,period2fitness_",cond,".status,period2fitness_",cond,".status2,patient_incidents_view.age,patient_incidents_view.sex,patient_incidents_view.copayment FROM period2fitness_",cond," LEFT JOIN patient_incidents_view ON period2fitness_",cond,".ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)

model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class
mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,                  
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint1_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 10, bty = "l", legend.loc = 'bottomright',
     ylab = "fitness", xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1000,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint2_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs",sprintf("joint3_%s.png",
                                         cond))),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)

```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_ob.png){#fig-joint1_ob fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_ob.png){#fig-joint2_ob fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_ob.png){#fig-joint3_ob fig-align="center" width="80%"}

### Process indicators' analysis

We selected incident patients with at least one year of follow-up to create a process indicator's event log. This log includes cholesterol, albumin-creatinine index, glycated hemoglobin, body mass index, blood pressure and glomerular filtration measures, and foot and eye examinations.
```{python}
#| label: Creating process indicators' event log (ob)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create process indicators' event log")
con = duckdb.connect(db_path)
evlog_process_ind(con)
con.close()
```

An activity presence analysis is done to see the percentage of presence of each indicator in analyzed traces.
```{r}
#| label: activity presence of process indicators
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
con <- dbConnect(duckdb(), dbdir = db_path)

log_info('Make activity presence of process_indicators')
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/activity_presence_process_indicators_year1.png")),
    width = 600, height = 750, units = "px")
eventlog <- dbGetQuery(con,
                      "SELECT patient_id,event,date,cycle,actins\
                       FROM process_ind1 WHERE event NOT IN ('INI','FIN') \
                       UNION ALL SELECT patient_id,event, \
                       CAST(date AS TIMESTAMP) + INTERVAL 1 SECOND AS date, \
                       'complete' AS cycle,actins\
                       FROM process_ind1 WHERE event NOT IN ('INI','FIN')")
activity_presence_df <- eventlog %>%
    mutate(resource = NA) %>%
    eventlog(
      case_id = "patient_id",
      activity_id = "event", 
      lifecycle_id = "cycle", 
      activity_instance_id = "actins", 
      timestamp = "date", 
      resource_id = 'resource'
    ) %>% activity_presence()  
plot(activity_presence_df[activity_presence_df$event != "yFIN",]
     )+scale_y_continuous(limits = c(0, 1))
dev.off()

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/activity_presence_process_indicators_year2.png")),
    width = 600, height = 750, units = "px")
eventlog <- dbGetQuery(con,
                      "SELECT patient_id,event,date,cycle,actins\
                       FROM process_ind2 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind1) \
                       UNION ALL SELECT patient_id,event, \
                       CAST(date AS TIMESTAMP) + INTERVAL 1 SECOND AS date, \
                       'complete' AS cycle,actins\
                       FROM process_ind2 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind1)")
activity_presence_df <- eventlog %>%
    mutate(resource = NA) %>%
    eventlog(
      case_id = "patient_id",
      activity_id = "event", 
      lifecycle_id = "cycle", 
      activity_instance_id = "actins", 
      timestamp = "date", 
      resource_id = 'resource'
    ) %>% activity_presence()  
plot(activity_presence_df[activity_presence_df$event != "yFIN",]
     )+scale_y_continuous(limits = c(0, 1))
dev.off()

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/activity_presence_process_indicators_year3.png")),
    width = 600, height = 750, units = "px")
eventlog <- dbGetQuery(con,
                      "SELECT patient_id,event,date,cycle,actins\
                       FROM process_ind3 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind2) \
                       UNION ALL SELECT patient_id,event, \
                       CAST(date AS TIMESTAMP) + INTERVAL 1 SECOND AS date, \
                       'complete' AS cycle,actins\
                       FROM process_ind3 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind2)")
activity_presence_df <- eventlog %>%
    mutate(resource = NA) %>%
    eventlog(
      case_id = "patient_id",
      activity_id = "event", 
      lifecycle_id = "cycle", 
      activity_instance_id = "actins", 
      timestamp = "date", 
      resource_id = 'resource'
    ) %>% activity_presence()  
plot(activity_presence_df[activity_presence_df$event != "yFIN",]
     )+scale_y_continuous(limits = c(0, 1))
dev.off()

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/activity_presence_process_indicators_year4.png")),
    width = 600, height = 750, units = "px")
eventlog <- dbGetQuery(con,
                      "SELECT patient_id,event,date,cycle,actins\
                       FROM process_ind4 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind3) \
                       UNION ALL SELECT patient_id,event, \
                       CAST(date AS TIMESTAMP) + INTERVAL 1 SECOND AS date, \
                       'complete' AS cycle,actins\
                       FROM process_ind4 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind3)")
activity_presence_df <- eventlog %>%
    mutate(resource = NA) %>%
    eventlog(
      case_id = "patient_id",
      activity_id = "event", 
      lifecycle_id = "cycle", 
      activity_instance_id = "actins", 
      timestamp = "date", 
      resource_id = 'resource'
    ) %>% activity_presence()  
plot(activity_presence_df[activity_presence_df$event != "yFIN",]
     )+scale_y_continuous(limits = c(0, 1))
dev.off()

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/activity_presence_process_indicators_year5.png")),
    width = 600, height = 750, units = "px")
eventlog <- dbGetQuery(con,
                      "SELECT patient_id,event,date,cycle,actins\
                       FROM process_ind5 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind4) \
                       UNION ALL SELECT patient_id,event, \
                       CAST(date AS TIMESTAMP) + INTERVAL 1 SECOND AS date, \
                       'complete' AS cycle,actins\
                       FROM process_ind5 WHERE actins NOT IN (\
                       SELECT actins FROM process_ind4)")
activity_presence_df <- eventlog %>%
    mutate(resource = NA) %>%
    eventlog(
      case_id = "patient_id",
      activity_id = "event", 
      lifecycle_id = "cycle", 
      activity_instance_id = "actins", 
      timestamp = "date", 
      resource_id = 'resource'
    ) %>% activity_presence()  
plot(activity_presence_df[activity_presence_df$event != "yFIN",]
     )+scale_y_continuous(limits = c(0, 1))
dev.off()


dbDisconnect(con, shutdown = TRUE)
```
![Percentage of patients' traces an activity is present during the first year](../../outputs/activity_presence_process_indicators_year1.png){#fig-activity_presence_year1 fig-align="center" width="80%"}

![Percentage of patients' traces an activity is present during the second year](../../outputs/activity_presence_process_indicators_year2.png){#fig-activity_presence_year2 fig-align="center" width="80%"}

![Percentage of patients' traces an activity is present during the third year](../../outputs/activity_presence_process_indicators_year3.png){#fig-activity_presence_year3 fig-align="center" width="80%"}

![Percentage of patients' traces an activity is present during the fourth year](../../outputs/activity_presence_process_indicators_year4.png){#fig-activity_presence_year4 fig-align="center" width="80%"}

![Percentage of patients' traces an activity is present during the fifth year](../../outputs/activity_presence_process_indicators_year5.png){#fig-activity_presence_year5 fig-align="center" width="80%"}


#### Conformace checking

As has been done before, in this section, the observed traces are compared with a specific theoretical process. However, instead of utilizing a single Petri net, five Petri nets are employed, one for each year, as the adherence is now considered in annual intervals from diabetes detection date.  

```{python}
#| label: Creating process indicators' conformance analysis
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
logging.info("Create process indicators' conformance analysis")
con = duckdb.connect(db_path)
query = "SELECT * FROM process_ind1"
df_1 = id2process_fitness(con,
                          query,
                          './PN_PI_year1.pnml',
                          pn_png_file='../../outputs/PN_process1.png',
                          ini_place='place37',
                          fin_place='place148',
                          id_col = 'patient_id',
                          event_col = 'event',
                          date_col='date')

query = "SELECT * FROM process_ind2"
df_2 = id2process_fitness(con,
                          query,
                          './PN_PI_year2.pnml',
                          pn_png_file='../../outputs/PN_process2.png',
                          ini_place='place37',
                          fin_place='place148',
                          id_col = 'patient_id',
                          event_col = 'event',
                          date_col='date')
                          
query = "SELECT * FROM process_ind3"
df_3 = id2process_fitness(con,
                          query,
                          './PN_PI_year3.pnml',
                          pn_png_file='../../outputs/PN_process3.png',
                          ini_place='place37',
                          fin_place='place148',
                          id_col = 'patient_id',
                          event_col = 'event',
                          date_col='date')
                          
query = "SELECT * FROM process_ind4"
df_4 = id2process_fitness(con,
                          query,
                          './PN_PI_year4.pnml',
                          pn_png_file='../../outputs/PN_process4.png',
                          ini_place='place37',
                          fin_place='place148',
                          id_col = 'patient_id',
                          event_col = 'event',
                          date_col='date')

query = "SELECT * FROM process_ind5"
df_5 = id2process_fitness(con,
                          query,
                          './PN_PI_year5.pnml',
                          pn_png_file='../../outputs/PN_process5.png',
                          ini_place='place37',
                          fin_place='place148',
                          id_col = 'patient_id',
                          event_col = 'event',
                          date_col='date')
                          
df2year = con.sql("SELECT *,1 AS year FROM df_1 \
                    UNION ALL SELECT *,2 AS year FROM df_2 \
                    UNION ALL SELECT *,3 AS year FROM df_3 \
                    UNION ALL SELECT *,4 AS year FROM df_4 \
                    UNION ALL SELECT *,5 AS year FROM df_5").df()
boxplot1 = sns.boxplot(x = df2year['year'], 
                       y = df2year['fitness'], 
                       palette = 'husl')
fig1 = boxplot1.get_figure()
fig1.savefig("../../outputs/fitness_by_year.png")
plt.close(fig1)
con.sql("DROP TABLE IF EXISTS period2process_fitness;")
con.sql("CREATE TABLE period2process_fitness AS \
SELECT ID, \
DATEDIFF('day', initial_date,date) AS t_0, \
DATEDIFF('day', initial_date,final_date) AS t_1, fitness, initial_date, \
status, MAX(status) OVER (PARTITION BY ID) AS status2 \
FROM (SELECT a.*,COALESCE(b.deregistration_date,'2022-12-31'),\
             COALESCE( LEAD(date, 1) OVER (PARTITION BY ID ORDER BY date), \
             LEAST(deregistration_date, \
                   COALESCE(admission_date,\
                            CAST('2022-12-31' AS DATE)) )) AS final_date, \
             CASE WHEN admission_date=final_date THEN 1 ELSE 0 END AS status, \
             MIN(date) OVER (PARTITION BY ID) AS initial_date\
             FROM (SELECT * FROM (SELECT df2year.*, \
                  cmbd_incidents_postdx_first_view.admission_date AS admission_date \
                  FROM df2year LEFT JOIN cmbd_incidents_postdx_first_view ON \
                    df2year.ID = cmbd_incidents_postdx_first_view.patient_id) \
                      WHERE date<admission_date OR admission_date IS NULL) a \
                  LEFT JOIN patient_incidents_view b ON a.ID=b.patient_id) WHERE t_0!=t_1")
```

![Boxplot of  process indicators' traces' fitness by cumulative years)](../../outputs/fitness_by_year.png){#fitness_by_year fig-align="center" width="80%"}

Treatments' analysis' and process indicators' fitness are linked with the next plot:
```{python}
#| label: Creating process indicators' conformance analysis by condition
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: FALSE
df2cond = con.sql("SELECT d.*, p.type AS type,p.date AS date_fin \
              FROM (SELECT *,1 AS year FROM df_1 \
                    UNION ALL SELECT *,2 AS year FROM df_2 \
                    UNION ALL SELECT *,3 AS year FROM df_3 \
                    UNION ALL SELECT *,4 AS year FROM df_4 \
                    UNION ALL SELECT *,5 AS year FROM df_5) d \
              LEFT JOIN patient_condition p ON d.ID = p.patient_id \
              WHERE d.date<=p.date").df()

boxplot2 = sns.boxplot(x = df2cond['type'], 
                      y = df2cond['fitness'], 
                      hue = df2cond['year'], 
                      palette = 'husl')
plt.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0, title='Year')
fig2 = boxplot2.get_figure()
fig2.savefig("../../outputs/fitness2cond_by_year.png")
plt.close(fig2)
con.close()
```

![Boxplot of process indicators' traces' fitness by cumulative year and by predominant clinical condition)](../../outputs/fitness2cond_by_year.png){#fitness2cond_by_year fig-align="center" width="80%"}

#### Prediction Models

In the next example, we choose fitness, age, sex and copayment to try to predict a hospitalization with a time dependent Cox model, and the summary of it is:


```{r}
#| label: Time dependent COX (process indicators)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE
con <- dbConnect(duckdb(), dbdir = db_path)

df <- dbGetQuery(con, paste0("SELECT period2process_fitness.ID, period2process_fitness.t_0, period2process_fitness.t_1, period2process_fitness.fitness, period2process_fitness.status,period2process_fitness.status2, patient_incidents_view.age, patient_incidents_view.sex, patient_incidents_view.copayment FROM period2process_fitness LEFT JOIN patient_incidents_view ON period2process_fitness.ID=patient_incidents_view.patient_id"))
dbDisconnect(con, shutdown = TRUE)

df$sex <- as.factor(df$sex)
df$ID2 <- as.numeric(as.factor(df$ID))
df$t_max <- ave(df$t_1, df$ID2, FUN = max)
df$t_min <- ave(df$t_0, df$ID2, FUN = min)

model <- coxph(Surv(t_0, t_1, status) ~ age + sex + fitness,
               data=df)

summary(model)
```


Using same predictive variables a joint latent class model of three classes is made:
```{r}
#| label: JLCM model (process indicators)
#| eval: TRUE
#| echo: FALSE
#| warning: FALSE
#| output: TRUE

### 1 latent class

mj1 <- Jointlcmm(fixed= fitness ~ t_0 ,random =~ t_0, subject="ID2",
                 survival = Surv(t_min,t_max,status2) ~ age+sex, hazard="Weibull",
                 hazardtype="PH",ng=1,data=df, verbose=FALSE,
                 B=c(1,1,0,0,0,0,1,0,1,1))
### 2 latent class
tryCatch(
{mj3 <- gridsearch(rep = 20, maxiter = 20, minit = mj1, 
                  Jointlcmm(fixed= fitness ~ t_0 ,mixture =~ t_0,
                            random=~t_0,subject="ID2",
                            survival = Surv(t_min,t_max,status2)~ age+sex,
                            hazard="Weibull",hazardtype="PH",
                            ng=2,data=df, verbose=FALSE))

summary(mj3)

postprob(mj3)

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/joint1_PI.png")),
    width = 600, height = 750, units = "px")
plot(mj3, which = "fit", var.time = "t_0", marg = F, break.times = 5, bty = "l",
     legend.loc = 'bottomright',ylab = "fitness",
     xlab = "Time in days",shades=TRUE,ylim = c(0.1,1.0))
dev.off()
 
d1 <- data.frame(t_0=seq(1,1200,length.out=100))
data.new <-data.frame(d1,age=65,sex=0)
mj3.pred <- predictY(mj3, data.new , var.time = "t_0")

png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/joint2_PI.png")),
    width = 600, height = 750, units = "px")
plot(mj3.pred, bty = "l", ylim = c(0, 1), legend.loc = 'bottomleft',
     ylab = "fitness", xlab = "days", lwd = 2)
dev.off()
png(filename=gsub("src/analysis-scripts/","",
                  here("outputs/joint3_PI.png")),
    width = 600, height = 750, units = "px")
plot(mj3, which = "survival", lwd = 2, legend.loc = 'bottomleft', bty = "l",
     xlab = "days", ylab = "event-free probability")
dev.off()},
error = function(cond_) {
            message(conditionMessage(cond_))
        }
)

```
![Class-specific weighted marginal and subject-specific mean predicted fitness trajectories](../../outputs/joint1_PI.png){#fig-joint1_PI fig-align="center" width="80%"}

![Class-specific mean predicted fitness trajectory](../../outputs/joint2_PI.png){#fig-joint2_PI fig-align="center" width="80%"}

![Class-specific survival functions](../../outputs/joint3_PI.png){#fig-joint3_PI fig-align="center" width="80%"}

### Joint latent class models' summary

::: {#fig-summary .column-page layout-ncol=3}

!['else' patients' class-specific weighted marginal and subject-specific mean predicted treatments' fitness trajectories](../../outputs/joint1_else.png){#fig-elsef1}

!['else' patients' class-specific mean  predicted treatments' fitness trajectory](../../outputs/joint2_else.png){#fig-elsef2}

!['else' patients' class-specific survival functions](../../outputs/joint3_else.png){#fig-elsef3}

![cvd patients' class-specific weighted marginal and subject-specific mean predicted treatments' fitness trajectories](../../outputs/joint1_cvd.png){#fig-cvdf1}

![cvd patients' class-specific mean  predicted treatments' fitness trajectory](../../outputs/joint2_cvd.png){#fig-cvdf2}

![cvd patients' class-specific survival functions](../../outputs/joint3_cvd.png){#fig-cvdf3}

![hf patients' class-specific weighted marginal and subject-specific mean predicted treatments' fitness trajectories](../../outputs/joint1_hf.png){#fig-hff1}

![hf patients' class-specific fitness mean  predicted treatments' fitness trajectory](../../outputs/joint2_hf.png){#fig-hff2}

![hf patients' class-specific survival functions](../../outputs/joint3_hf.png){#fig-hff3}

![ckd patients' class-specific weighted marginal and subject-specific mean predicted treatments' fitness trajectories](../../outputs/joint1_ckd.png){#fig-ckdf1}

![ckd patients' class-specific mean  predicted treatments' fitness trajectory](../../outputs/joint2_ckd.png){#fig-ckdf2}

![ckd patients' class-specific survival functions](../../outputs/joint3_ckd.png){#fig-ckdf3}

![Fragile patients' class-specific weighted marginal and subject-specific mean predicted treatments' fitness trajectories](../../outputs/joint1_f.png){#fig-ff1}

![Fragile patients' class-specific mean  predicted treatments' fitness trajectory](../../outputs/joint2_f.png){#fig-ff2}

![Fragile patients' class-specific survival functions](../../outputs/joint3_f.png){#fig-ff3}

![Obese patients' class-specific weighted marginal and subject-specific mean predicted treatments' fitness trajectories](../../outputs/joint1_ob.png){#fig-obf1}

![Obese patients' class-specific mean  predicted treatments' fitness trajectory](../../outputs/joint2_ob.png){#fig-obf2}

![Obese patients' class-specific survival functions](../../outputs/joint3_ob.png){#fig-obf3}

![Class-specific weighted marginal and subject-specific mean predicted process indicators' fitness trajectories](../../outputs/joint1_PI.png){#fig-pf1}

![Class-specific mean  predicted process indicators' fitness trajectory](../../outputs/joint2_PI.png){#fig-pf2}

![Class-specific survival functions](../../outputs/joint3_PI.png){#fig-pf3}

Joint latent class models' plots' panel
:::